<!doctypehtml><html data-theme=dark lang=en><meta charset=UTF-8><meta content="width=device-width,initial-scale=1"name=viewport><title>Green Screen Vault - Free Overlays, Memes & Clips</title><meta content="Discover thousands of free green screen overlays, effects, transitions, meme templates, and video clips. Perfect for YouTube, streaming (OBS), social media (TikTok/Reels), and film projects. Download CC0 chroma key footage instantly. Upload your own!"name=description><meta content="green screen, chroma key, video overlay, free download, video effects, transitions, stock footage, video clips, meme template, green screen download, video editing assets, content creator resources, premiere pro, after effects, final cut pro, davinci resolve, obs studio, streamlabs, tiktok, reels, youtube shorts, cc0 license, public domain video, free green screen memes, chroma key memes, green screen effects download, free video assets, motion graphics elements"name=keywords><meta content="index, follow"name=robots><meta content=KW9LITbigX2kYkD1Pt-ShwyWVkKL24BSvGMcRAR33L4 name=google-site-verification><script src=https://upload-widget.cloudinary.com/global/all.js></script><link href=https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@400;700&display=swap"rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css rel=stylesheet crossorigin=anonymous integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="referrerpolicy=no-referrer><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5641687897051414"async crossorigin=anonymous></script><style>body{font-family:Roboto,sans-serif;transition:background .5s ease,color .5s ease;line-height:1.6;overflow-x:hidden}html[data-theme=dark] body{background:#0a0a0a;color:#e5e7eb}html[data-theme=light] body{background:#f8f9fa;color:#212529}.header{background:linear-gradient(90deg,#0f8,#0cf);color:#000;padding:1rem 1rem;text-align:center;font-size:1.8rem;font-weight:700;position:relative;box-shadow:0 4px 10px rgba(0,255,136,.3);z-index:40;display:flex;align-items:center;justify-content:center}.header h1{animation:fadeInDown 1s ease-in-out;font-family:Orbitron,sans-serif;letter-spacing:1px;margin:0;flex-grow:1;text-align:center}.header-buttons-container{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;justify-content:space-between;align-items:center;padding:0 1rem;pointer-events:none}.header-buttons{display:flex;gap:.5rem;pointer-events:auto}.header-btn{background:rgba(0,0,0,.5);color:#fff;border:1px solid rgba(255,255,255,.5);padding:.4rem .8rem;border-radius:.5rem;font-size:.9rem;cursor:pointer;transition:background-color .2s,transform .2s;display:flex;align-items:center;gap:.3rem;position:relative;z-index:41;overflow:hidden}.header-btn:hover{background:rgba(0,0,0,.7);transform:scale(1.05)}html[data-theme=light] .header-btn{background:rgba(255,255,255,.7);color:#000;border-color:rgba(0,0,0,.2)}html[data-theme=light] .header-btn:hover{background:rgba(255,255,255,.9)}.header-btn i{transition:transform .2s ease-in-out;display:inline-block}.header-btn:hover i{transform:scale(1.15) rotate(-5deg)}@media (min-width:640px){.header{font-size:2.5rem;padding:1.5rem 1rem}.header-buttons-container{padding:0 1.5rem}}@media (max-width:639px){.header-btn span.button-text{display:none}.header-btn{padding:.5rem}.header h1{font-size:1.5rem}.header{padding:1rem .5rem}.header-buttons-container{padding:0 .5rem}}.theme-icon{position:absolute;top:-25px;left:50%;transform:translateX(-50%);font-size:1.5rem;transition:transform .6s cubic-bezier(.68,-.55,.27,1.55),opacity .6s ease;opacity:0;pointer-events:none;z-index:40}#sunIcon{color:#fc0}#moonIcon{color:khaki}html:not([data-theme=light]) #moonIcon{transform:translate(-50%,40px);opacity:1}html:not([data-theme=light]) #sunIcon{transform:translate(-50%,80px);opacity:0}html[data-theme=light] #sunIcon{transform:translate(-50%,40px);opacity:1}html[data-theme=light] #moonIcon{transform:translate(-50%,80px);opacity:0}.gallery{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:1.5rem;padding:1.5rem}.card{background:#1f1f1f;border-radius:1rem;overflow:hidden;border:1px solid #333;box-shadow:0 4px 15px rgba(0,255,136,.1);transition:transform .3s ease,box-shadow .3s ease,border-color .3s ease,opacity .4s ease,height .4s ease,margin .4s ease,padding .4s ease,border-width .4s ease;animation:fadeInUp .5s ease-in-out both;position:relative;display:flex;flex-direction:column}html[data-theme=light] .card{background:#fff;color:#000;border-color:#e2e8f0;box-shadow:0 4px 6px rgba(0,0,0,.05)}.card:hover{transform:translateY(-6px) scale(1.03);box-shadow:0 10px 30px rgba(0,255,136,.28);border-color:#0f8}html[data-theme=light] .card:hover{box-shadow:0 8px 16px rgba(0,0,0,.12);border-color:#10b981}.video-container{cursor:pointer;position:relative;background-color:#050505;overflow:hidden;border-radius:1rem 1rem 0 0}.video-container video{width:100%;height:auto;aspect-ratio:16/9;object-fit:cover;display:block}.video-container::after{content:'\f04b';font-family:'Font Awesome 6 Free';font-weight:900;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3rem;color:rgba(255,255,255,.8);opacity:0;transition:opacity .3s ease,transform .3s ease;pointer-events:none;text-shadow:0 0 10px rgba(0,0,0,.5)}.video-container:hover::after{opacity:1;transform:translate(-50%,-50%) scale(1.1)}.video-container.playing::after{opacity:0!important}.card-content{padding:1rem;flex-grow:1}.card-title{font-weight:700;margin-bottom:.25rem;line-height:1.3;height:2.6em;overflow:hidden;font-size:1rem;word-break:break-all}.meta-info{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem;font-size:.8rem;gap:.5rem}.uploader-name{opacity:.8;color:#bbb;text-align:right}html[data-theme=light] .uploader-name{opacity:.9;color:#555}.download-count{font-size:.75rem;color:#888;display:flex;align-items:center;gap:.2rem;flex-shrink:0}html[data-theme=light] .download-count{color:#666}.download-count i{font-size:.7rem;animation:icon-pulse 2.5s infinite ease-in-out;display:inline-block}.card-footer{padding:0 1rem 1rem;display:flex;justify-content:space-between;align-items:center;gap:.5rem;border-top:1px solid #333;margin-top:auto}html[data-theme=light] .card-footer{border-top-color:#e2e8f0}.download-btn{background:#0f8;color:#000;padding:.5rem 1rem;text-align:center;font-weight:700;display:inline-flex;align-items:center;gap:.4rem;border-radius:.5rem;font-size:.85rem;line-height:1;transition:background-color .2s ease,transform .2s ease}.download-btn:hover{background-color:#00e67a;transform:scale(1.05)}.download-btn i{transition:transform .3s cubic-bezier(.68,-.55,.27,1.55);display:inline-block}.download-btn:hover i{transform:translateY(-2px) scale(1.1)}html[data-theme=light] .download-btn{background:#10b981;color:#fff}html[data-theme=light] .download-btn:hover{background:#0f9e73}.menu-btn{background:rgba(255,255,255,.1);border:1px solid #555;border-radius:50%;width:32px;height:32px;font-weight:700;cursor:pointer;line-height:1;color:#aaa;display:flex;align-items:center;justify-content:center;transition:background-color .2s,color .2s,border-color .2s,transform .3s ease}html[data-theme=light] .menu-btn{background:rgba(0,0,0,.05);border-color:#ccc;color:#555}.menu-btn i{transition:transform .3s ease;display:inline-block}.menu-btn:hover{background:rgba(0,255,136,.3);color:#fff;border-color:#0f8;transform:scale(1.1)}.menu-btn:hover i{transform:rotate(90deg)}html[data-theme=light] .menu-btn:hover{background:rgba(16,185,129,.2);color:#10b981;border-color:#10b981}.action-popup{display:none;position:absolute;bottom:45px;right:5px;background-color:#2a2a2a;border:1px solid #444;border-radius:8px;padding:.5rem;box-shadow:0 5px 15px rgba(0,0,0,.4);z-index:50;animation:popUpFadeIn .2s ease-out;min-width:130px}html[data-theme=light] .action-popup{background-color:#fff;border-color:#ccc;box-shadow:0 4px 15px rgba(0,0,0,.15)}.action-popup button{display:flex;align-items:center;gap:.5rem;width:100%;background:0 0;border:none;color:#0cf;padding:.6rem .8rem;text-align:left;cursor:pointer;border-radius:4px;font-size:.9rem;transition:background-color .15s,color .15s}.action-popup button i{transition:transform .2s ease-out;display:inline-block;width:1rem;text-align:center}.action-popup button:hover i{transform:scale(1.1) rotate(-3deg)}html[data-theme=light] .action-popup button{color:#0c4a6e}.action-popup button:hover{background-color:#3a3a3a}html[data-theme=light] .action-popup button:hover{background-color:#e5e7eb}.action-popup button.delete-action{color:#f55}html[data-theme=light] .action-popup button.delete-action{color:#dc2626}.action-popup button.delete-action:hover{background-color:rgba(255,85,85,.1)}html[data-theme=light] .action-popup button.delete-action:hover{background-color:#fee2e2}.modal-backdrop{position:fixed;inset:0;background-color:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;z-index:50;animation:fadeIn .4s ease-out;backdrop-filter:blur(5px)}@keyframes weirdModalPopIn{0%{opacity:0;transform:translateY(50px) scale(.8) skewX(-10deg)}60%{opacity:1;transform:translateY(-10px) scale(1.05) skewX(5deg)}80%{transform:translateY(5px) scale(.98) skewX(-2deg)}100%{opacity:1;transform:translateY(0) scale(1) skewX(0)}}@keyframes fadeOut{from{opacity:1}to{opacity:0}}.modal-backdrop.modal-fade-out{animation:fadeOut .3s ease-out forwards}.modal-backdrop.modal-fade-out .modal-box{animation:fadeOut .3s ease-out forwards}.modal-box{background-color:#1f1f1f;color:#fff;padding:1.5rem;border-radius:1rem;border:1px solid #444;box-shadow:0 10px 30px rgba(0,0,0,.6);width:90%;max-width:500px;animation:weirdModalPopIn .6s cubic-bezier(.34,1.56,.64,1) forwards;position:relative;max-height:85vh;overflow-y:auto}html[data-theme=light] .modal-box{background-color:#fff;color:#000;border-color:#ccc;box-shadow:0 5px 20px rgba(0,0,0,.15)}@media (min-width:640px){.modal-box{padding:2rem}}.modal-box h2{font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#0f8;text-align:center}.modal-box h2 i{animation:icon-pulse 2s infinite ease-in-out;margin-right:.5rem;display:inline-block}html[data-theme=light] .modal-box h2{color:#10b981}.modal-box label{display:block;margin-bottom:.5rem;font-size:.9rem;font-weight:700;color:#ccc}html[data-theme=light] .modal-box label{color:#555}.modal-box input[type=password],.modal-box input[type=text],.modal-box textarea{width:100%;padding:.8rem;border-radius:.5rem;background-color:#333;border:1px solid #555;color:#fff;margin-bottom:1rem;transition:border-color .2s,box-shadow .2s;font-size:.95rem}.modal-box input:focus,.modal-box textarea:focus{outline:0;border-color:#0f8;box-shadow:0 0 0 3px rgba(0,255,136,.4)}html[data-theme=light] .modal-box input[type=password],html[data-theme=light] .modal-box input[type=text],html[data-theme=light] .modal-box textarea{background-color:#e5e7eb;border-color:#ccc;color:#000}html[data-theme=light] .modal-box input:focus,html[data-theme=light] .modal-box textarea:focus{border-color:#10b981;box-shadow:0 0 0 3px rgba(16,185,129,.3)}.modal-buttons{display:flex;flex-wrap:wrap;justify-content:flex-end;gap:.75rem;margin-top:1.5rem}.modal-buttons button{font-size:.9rem;padding:.7rem 1.2rem;border-radius:.5rem;border:none;cursor:pointer;font-weight:700;transition:background-color .2s,transform .2s,box-shadow .2s;display:inline-flex;align-items:center;justify-content:center;gap:.5rem}.modal-buttons button:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,.2)}.modal-buttons button i{transition:transform .2s ease;display:inline-block}.modal-buttons button:hover i{transform:scale(1.1)}.modal-button-confirm{background-color:#0f8;color:#000}.modal-button-confirm:hover{background-color:#0d7}html[data-theme=light] .modal-button-confirm{background-color:#10b981;color:#fff}html[data-theme=light] .modal-button-confirm:hover{background-color:#0f9e73}.modal-button-cancel{background-color:#555;color:#fff}.modal-button-cancel:hover{background-color:#666}html[data-theme=light] .modal-button-cancel{background-color:#a1a1aa;color:#000}html[data-theme=light] .modal-button-cancel:hover{background-color:#71717a}.modal-button-delete{background-color:#f44;color:#fff}.modal-button-delete:hover{background-color:#d22}html[data-theme=light] .modal-button-delete{background-color:#dc2626;color:#fff}html[data-theme=light] .modal-button-delete:hover{background-color:#b91c1c}.modal-error{color:#f55;font-size:.85rem;margin-top:-.5rem;margin-bottom:1rem;min-height:1.2em;text-align:center;display:block}.modal-close-btn{position:absolute;top:12px;right:12px;background:rgba(255,255,255,.1);border:none;font-size:1.5rem;color:#aaa;cursor:pointer;line-height:1;z-index:51;padding:.1rem .5rem;border-radius:50%;transition:background-color .2s,color .2s,transform .2s}html[data-theme=light] .modal-close-btn{background:rgba(0,0,0,.05);color:#777}.modal-close-btn:hover{background:rgba(255,255,255,.2);color:#fff;transform:scale(1.1) rotate(90deg)}html[data-theme=light] .modal-close-btn:hover{background:rgba(0,0,0,.1);color:#000}#termsModal .modal-box{max-width:700px}.terms-content{font-size:.9rem;line-height:1.6;max-height:60vh;overflow-y:auto;border:1px solid #444;padding:1rem 1.5rem;border-radius:.5rem;margin-bottom:1rem;background-color:rgba(0,0,0,.15)}html[data-theme=light] .terms-content{border-color:#ccc;background-color:rgba(0,0,0,.03)}.terms-content h3{font-weight:700;margin-top:1rem;margin-bottom:.5rem;color:#0cf}html[data-theme=light] .terms-content h3{color:#0ea5e9}.terms-accept-label{display:flex;align-items:center;margin-top:1rem;cursor:pointer;font-size:.9rem}html[data-theme=dark] .terms-accept-label{color:#ccc}html[data-theme=light] .terms-accept-label{color:#333}.terms-accept-label input{margin-right:.75rem;width:1rem;height:1rem;accent-color:#0f8;transform:scale(1.1);cursor:pointer}html[data-theme=light] .terms-accept-label input{accent-color:#10b981}.filter-search-area{padding:1.5rem;background-color:rgba(0,0,0,.15);border-bottom:1px solid #333;position:sticky;top:0;z-index:30;backdrop-filter:blur(3px)}html[data-theme=light] .filter-search-area{background-color:rgba(255,255,255,.7);border-bottom-color:#e2e8f0;backdrop-filter:blur(5px)}.filter-options{display:flex;justify-content:center;gap:.75rem;margin-bottom:1rem;flex-wrap:wrap}.filter-btn{padding:.5rem 1rem;margin:0;text-align:center;font-weight:700;border-radius:.5rem;cursor:pointer;transition:all .2s ease;border:2px solid transparent;font-size:.85rem}.filter-btn:hover:not(.active-filter){transform:translateY(-2px)}.filter-btn.active-filter{transform:translateY(-1px)}.search-container{display:flex;justify-content:center;align-items:center;max-width:400px;margin:0 auto;position:relative}.search-container label{display:none}.search-container input{flex-grow:1;padding:.7rem 1rem .7rem 2.5rem;border-radius:1rem;background-color:#333;border:1px solid #555;color:#fff;transition:border-color .2s,box-shadow .2s}.search-container::before{content:'\f002';font-family:'Font Awesome 6 Free';font-weight:900;position:absolute;left:1rem;top:50%;transform:translateY(-50%);color:#888;font-size:.9rem;transition:color .2s,transform .2s;pointer-events:none}html[data-theme=light] .search-container::before{color:#777}.search-container input:focus+label+::before,.search-container:focus-within::before{color:#0cf;transform:translateY(-50%) scale(1.1)}html[data-theme=light] .search-container:focus-within::before{color:#38bdf8}.search-container input:focus{outline:0;border-color:#0cf;box-shadow:0 0 0 3px rgba(0,204,255,.3)}html[data-theme=light] .search-container input:focus{border-color:#38bdf8;box-shadow:0 0 0 3px rgba(56,189,248,.3)}html[data-theme=light] .search-container input{background-color:#e5e7eb;border-color:#ccc;color:#000}@keyframes animated-gradient{0%{background-position:0 50%}50%{background-position:100% 50%}100%{background-position:0 50%}}#introScreen{position:fixed;inset:0;background:linear-gradient(135deg,#001a11,#002030,#001a11);background-size:300% 300%;animation:animated-gradient 15s ease infinite;display:flex;align-items:center;justify-content:center;z-index:100;color:#fff;font-family:Orbitron,sans-serif;opacity:1;transition:opacity 1.2s ease-out .5s,visibility 0s linear 1.7s;pointer-events:auto;visibility:visible;overflow:hidden}#introScreen.fade-out{opacity:0;pointer-events:none;visibility:hidden}@keyframes textPopInGlowRefined{0%{opacity:0;transform:scale(.5) translateY(50px);text-shadow:0 0 5px rgba(0,255,136,.5);filter:blur(3px)}60%{opacity:1;transform:scale(1.1) translateY(0);text-shadow:0 0 10px #0f8,0 0 20px #0f8,0 0 30px #0cf,0 0 40px #0cf;filter:blur(0)}100%{opacity:1;transform:scale(1) translateY(0);text-shadow:0 0 8px #0f8,0 0 15px #0cf;filter:blur(0)}}#introText{font-size:2.5rem;font-weight:700;letter-spacing:2px;opacity:0;animation:textPopInGlowRefined 2.2s cubic-bezier(.25,.46,.45,.94) .2s forwards}@media (min-width:640px){#introText{font-size:3.8rem}}@media (max-width:480px){#introText{font-size:1.8rem}}#loadMoreBtn{display:block;margin:2.5rem auto;padding:.8rem 2.5rem;font-weight:700;cursor:pointer;border-radius:.5rem;transition:background-color .2s,transform .2s,box-shadow .2s,opacity .2s;font-size:.9rem;background:#0cf;color:#000;border:none;text-transform:uppercase;letter-spacing:.5px}html[data-theme=light] #loadMoreBtn{background:#38bdf8;color:#fff}#loadMoreBtn:hover:not(:disabled){transform:translateY(-3px) scale(1.03);box-shadow:0 5px 10px rgba(0,204,255,.3)}html[data-theme=dark] #loadMoreBtn:hover:not(:disabled){background-color:#0df}html[data-theme=light] #loadMoreBtn:hover:not(:disabled){background-color:#0ea5e9;box-shadow:0 5px 10px rgba(56,189,248,.3)}#loadMoreBtn:disabled{background:#555;cursor:not-allowed;transform:none;opacity:.6;box-shadow:none}html[data-theme=light] #loadMoreBtn:disabled{background:#a1a1aa}#loadMoreBtn .fa-spinner{animation:spin 1s linear infinite;display:inline-block;margin-right:.5rem}.info-section{padding:3rem 1.5rem;text-align:center;border-top:1px solid #222;margin-top:2rem}html[data-theme=light] .info-section{border-top-color:#eee}.info-section h2{font-size:2rem;font-weight:700;margin-bottom:1rem;color:#0f8;font-family:Orbitron,sans-serif}html[data-theme=light] .info-section h2{color:#10b981}.info-section h3{font-size:1.4rem;font-weight:700;margin-top:2.5rem;margin-bottom:1rem;color:#0cf}html[data-theme=light] .info-section h3{color:#0ea5e9}.info-section h3 i{display:inline-block;transition:transform .3s ease}.info-section h3:hover i{transform:scale(1.15) rotate(-5deg)}html[data-theme=dark] .info-section ol{color:#bbb}html[data-theme=light] .info-section ol,html[data-theme=light] .info-section p{color:#4b5563}.info-section ol{text-align:left;padding-left:1.5rem;list-style-position:inside;list-style-type:decimal}.info-section ol li{margin-bottom:.5rem}.info-section i.fa-eye-dropper{animation:icon-bounce 1.5s infinite;display:inline-block}.info-section i.fa-lightbulb{animation:icon-pulse 2s infinite ease-in-out;display:inline-block}.info-section .info-cta i{transition:transform .2s ease;display:inline-block}.info-section .info-cta:hover i{transform:scale(1.1) translateX(3px)}.info-section code{background-color:rgba(255,255,255,.15);padding:.2em .5em;border-radius:4px;font-size:.9em;color:#0f8}html[data-theme=light] .info-section code{background-color:rgba(0,0,0,.07);color:#10b981}.video-wrapper{max-width:700px;margin:2rem auto;box-shadow:0 8px 25px rgba(0,0,0,.3);border-radius:1rem;overflow:hidden;position:relative;padding-bottom:56.25%;height:0;background:#000}html[data-theme=light] .video-wrapper{box-shadow:0 6px 20px rgba(0,0,0,.1)}.video-wrapper iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:0}.info-cta{margin-top:2rem;display:inline-block;background:linear-gradient(90deg,#0f8,#0cf);color:#000;padding:.8rem 1.8rem;border-radius:50px;font-weight:700;text-decoration:none;transition:transform .2s ease,box-shadow .2s ease}.info-cta:hover{transform:scale(1.05);box-shadow:0 5px 15px rgba(0,255,136,.4)}.info-section .fa-info-circle{animation:icon-pulse 2s infinite ease-in-out;display:inline-block}.tooltip{position:relative;display:inline-block;cursor:help;border-bottom:1px dotted #0cf}html[data-theme=light] .tooltip{border-bottom-color:#0ea5e9}.tooltip .tooltiptext{visibility:hidden;width:220px;background-color:#2a2a2a;color:#fff;text-align:center;border-radius:6px;padding:10px;position:absolute;z-index:60;bottom:130%;left:50%;margin-left:-110px;opacity:0;transition:opacity .3s ease,transform .3s ease;font-size:.85rem;line-height:1.4;border:1px solid #444;box-shadow:0 3px 8px rgba(0,0,0,.4);transform:translateY(10px)}html[data-theme=light] .tooltip .tooltiptext{background-color:#f0f0f0;color:#333;border-color:#ccc;box-shadow:0 2px 5px rgba(0,0,0,.15)}.tooltip:hover .tooltiptext{visibility:visible;opacity:1;transform:translateY(0)}.site-footer{text-align:center;padding:2rem 1rem;margin-top:3rem;font-size:.9rem;border-top:1px solid #333;background-color:rgba(0,0,0,.2)}html[data-theme=light] .site-footer{border-top-color:#ddd;background-color:rgba(0,0,0,.03)}.footer-links{margin-top:.5rem;display:flex;justify-content:center;gap:1rem;flex-wrap:wrap}.footer-link{color:#0cf;text-decoration:none;cursor:pointer;transition:color .2s,transform .2s;display:inline-block}html[data-theme=light] .footer-link{color:#0ea5e9}.footer-link:hover{color:#0f8;text-decoration:underline;transform:translateY(-1px)}html[data-theme=light] .footer-link:hover{color:#10b981}.ad-placeholder{background-color:rgba(128,128,128,.1);border:1px dashed #555;min-height:90px;display:flex;align-items:center;justify-content:center;text-align:center;color:#888;font-size:.9rem;margin:1.5rem auto;max-width:728px}html[data-theme=light] .ad-placeholder{background-color:#eee;border-color:#ccc;color:#777}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes glow{from{filter:drop-shadow(0 0 5px #0f8)}to{filter:drop-shadow(0 0 15px #0cf)}}@keyframes fadeInUp{from{opacity:0;transform:translateY(25px)}to{opacity:1;transform:translateY(0)}}@keyframes fadeInDown{from{opacity:0;transform:translateY(-25px)}to{opacity:1;transform:translateY(0)}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes popUpFadeIn{from{opacity:0;transform:translateY(10px) scale(.95)}to{opacity:1;transform:translateY(0) scale(1)}}@keyframes icon-bounce{0%,100%{transform:translateY(0) scale(1)}50%{transform:translateY(-3px) scale(1.1)}}@keyframes icon-pulse{0%,100%{transform:scale(1);opacity:.8}50%{transform:scale(1.15);opacity:1}}@keyframes icon-wiggle{0%,100%{transform:rotate(0)}25%{transform:rotate(-8deg) scale(1.1)}75%{transform:rotate(8deg) scale(1.1)}}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.footer-link,.tooltip,[role=button],a[onclick],button,input[type=checkbox],label[for]{cursor:pointer}.progress-container{width:100%;background:#333;border-radius:10px;overflow:hidden;height:12px;margin-top:1rem}html[data-theme=light] .progress-container{background:#e5e7eb}.progress-bar{height:100%;background:linear-gradient(270deg,#0f8,#0cf);animation:glow 1.5s infinite alternate;width:0%;transition:width .4s ease;border-radius:10px}#uploadStatus{margin-top:.8rem;font-size:.9rem;min-height:1.4em;text-align:center}.gallery-message{text-align:center;width:100%;grid-column:1/-1;font-size:1.1rem;padding:2rem;margin-top:1rem;border-radius:.5rem}.gallery-message.info{color:#9ca3af}html[data-theme=light] .gallery-message.info{color:#4b5563}.gallery-message.error{color:#f87171;background-color:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.3)}html[data-theme=light] .gallery-message.error{color:#dc2626;background-color:#fee2e2;border:1px solid #fecaca}.gallery-message.empty{color:#60a5fa}html[data-theme=light] .gallery-message.empty{color:#3b82f6}.gallery-message.end-of-list{animation:fadeInUp .5s ease-out}.card.deleting{opacity:0!important;transform:scale(.9)!important;height:0!important;margin:0!important;padding-top:0!important;padding-bottom:0!important;border-width:0!important;overflow:hidden!important}</style><div id=introScreen><span id=introText>Green Screen Vault</span></div><header class=header><h1>🎬 Green Screen Vault</h1><div class=header-buttons-container><div class="header-buttons left"><button type=button class=header-btn id=themeToggleBtn aria-label="Toggle color theme"title="Toggle Theme"><i class="fas fa-adjust"></i> <span class="sr-only button-text sm:not-sr-only">Theme</span><div class=theme-icon id=sunIcon aria-hidden=true><i class="fas fa-sun"></i></div><div class=theme-icon id=moonIcon aria-hidden=true><i class="fas fa-moon"></i></div></button></div><div class="header-buttons right"><button type=button class=header-btn id=showUploadBtn aria-label="Open video upload popup"title="Upload Video"><i class="fas fa-upload"></i> <span class="sr-only button-text sm:not-sr-only">Upload</span></button></div></div></header><div class=filter-search-area><div class=filter-options aria-label="Video Filters"role=tablist><button type=button class=filter-btn id=filter-recent aria-selected=true data-filter=recent role=tab>Most Recent</button> <button type=button class=filter-btn id=filter-popular aria-selected=false data-filter=popular role=tab>Popular</button></div><div class=search-container><label for=search class=sr-only>Search Videos:</label> <input id=search placeholder="Search clips by title or uploader..."type=search aria-label="Search green screen clips"></div></div><main><div class=gallery id=gallery aria-live=polite><p class="gallery-message info"id=gallery-loading-msg>🔄 Loading Videos...</div><button type=button id=loadMoreBtn style=display:none>Load More Videos</button><section class="info-section landing-page"><h2><i class="fas mr-2 fa-lightbulb"></i>Unlock Your Creativity</h2><p>Welcome to the Green Screen Vault! Your ultimate destination for free <span class=tooltip>chroma key<span class=tooltiptext>Chroma key compositing, or chroma keying, is a visual effects technique for compositing two images or video streams together based on color hues (chroma range).</span></span> footage and video clips. Find dynamic effects, transitions, elements, and <strong class="text-green-400 dark:text-green-300">even popular meme templates</strong> to elevate your video projects – all free to download and use! Find the perfect clip for your next video.<div class=video-wrapper><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"allowfullscreen frameborder=0 loading=lazy src=https://www.youtube.com/embed/-UFG_jU3bXA title="YouTube video player - Green Screen Tutorial (Adobe Premiere Pro Ultra Key)"></iframe></div><h3><i class="fas mr-1 fa-question-circle"></i>Quick Guide: Using Overlays (Premiere Pro Example)</h3><ol><li><strong>Import:</strong> Add your main footage and the downloaded green screen clip (.mp4, .mov) to your project.<li><strong>Layer:</strong> Place the overlay clip on the timeline track <strong>above</strong> your main footage.<li><strong>Effect:</strong> Search for <code>Ultra Key</code> in the Effects panel and drag it onto the overlay clip.<li><strong>Key Color:</strong> In Effect Controls > Ultra Key, use the eyedropper <i class="fas fa-eye-dropper"aria-hidden=true></i> to select the green (or blue) screen color in the Program Monitor.<li><strong>Refine:</strong> Adjust Matte Generation/Cleanup/Spill Suppression settings for a clean key. Experiment with <span class=tooltip>Choke<span class=tooltiptext>Reduces the size of the matte slightly to hide faint edges.</span></span> and <span class=tooltip>Soften<span class=tooltiptext>Blurs the edges of the matte for smoother blending.</span></span> for best results.<li><strong>Composite:</strong> Position, scale, or animate the keyed overlay layer as needed to blend it into your scene!</ol><h3><i class="fas mr-1 fa-rocket"></i> Pro Tips & Benefits for Content Creators</h3><p>Using pre-made green screen clips saves significant time compared to creating complex effects from scratch. They add professional polish to YouTube videos, live streams (OBS/Streamlabs), social media content (TikTok/Instagram Reels), and indie films. This vault thrives on community contributions – consider uploading your own creations! Share your awesome green screen effects, transitions, video elements, or even those hilarious <strong class="text-green-400 dark:text-green-300">meme templates</strong> everyone is looking for! Help fellow creators find the perfect video clips.<p><strong>Shooting Tip:</strong> Ensure your green screen is evenly lit and wrinkle-free for the easiest keying. Avoid green clothing or highly reflective objects on your subject. Consistent lighting is key!<div class=mt-8><div class="text-sm bg-teal-100 dark:bg-teal-900 dark:text-teal-200 inline-block p-3 rounded-lg shadow-md text-teal-800"><i class="fas mr-1 fa-info-circle"aria-hidden=true></i> This site uses <span class=tooltip>Cloudinary<span class=tooltiptext>A cloud-based service for managing and delivering images and videos efficiently.</span></span> for video hosting and optimized delivery. All uploaded content is licensed under <span class=tooltip>CC0 (Public Domain)<span class=tooltiptext>Creative Commons Zero - Content can be copied, modified, distributed, and performed, even for commercial purposes, all without asking permission.</span></span>.</div></div><div class=mt-8><a class=info-cta href=# id=scrollToUpload><i class="fas mr-2 fa-share-alt"aria-hidden=true></i>Contribute Your Overlay!</a></div></section></main><div class=modal-backdrop id=uploadPopup><div class="modal-box max-w-md w-full"><button type=button class=modal-close-btn data-action=close-modal aria-label="Close Upload Popup">×</button><h2><i class="fas mr-2 fa-cloud-upload-alt"aria-hidden=true></i>Upload Overlays</h2><p class="mb-4 text-center text-gray-400 text-sm">Help the community grow! Share effects, transitions, or meme templates.<div><label for=uploaderNameInput>Your Name/Alias (Optional):</label> <input id=uploaderNameInput class=mb-4 aria-describedby=uploaderHelp placeholder="Shown publicly with your video(s)"><p class=sr-only id=uploaderHelp>Enter the name you want displayed as the uploader</div><div><label for=deletePassword>Deletion Password (Required):</label> <input id=deletePassword class=mb-4 aria-describedby=passwordHelp placeholder="Save this password securely!"required type=password><p class="mb-4 -mt-2 text-gray-500 text-xs"id=passwordHelp>6+ characters. Needed if you ever want to delete your upload(s).</div><button type=button class="justify-center w-full modal-button-confirm py-3 text-base"id=selectUploadBtn><i class="fas mr-2 fa-file-video"aria-hidden=true></i> Select & Upload Video(s)</button><div class="mt-4 progress-container"id=progressContainer aria-label="Upload progress"style=display:none><div class=progress-bar id=progressBar aria-valuemax=100 aria-valuemin=0 aria-valuenow=0 role=progressbar></div></div><p class="text-sm text-center h-5 mt-2"id=uploadStatus aria-live=polite></p><button type=button class="justify-center w-full modal-button-cancel mt-2"data-action=close-modal>Cancel</button></div></div><div class=modal-backdrop id=promptModal><div class=modal-box><button type=button class=modal-close-btn data-action=close-prompt aria-label="Close Prompt">×</button><h2 id=promptTitle>Prompt</h2><div class="mb-4 mt-4"id=promptContent><p class=modal-error id=promptError aria-live=assertive style=display:none></div><div class=modal-buttons><button type=button class=modal-button-cancel data-action=close-prompt id=promptCancelBtn>Cancel</button> <button type=button class=modal-button-confirm id=promptConfirmBtn>Confirm</button></div></div></div><div class=modal-backdrop id=uploadSuccessPopup><div class="modal-box text-center"><button type=button class=modal-close-btn data-action=close-modal aria-label="Close Success Popup">×</button><h2 class=text-2xl><i class="fas mr-2 text-blue-400 fa-rocket"aria-hidden=true></i>Upload Complete!</h2><div class=my-5 id=uploadSuccessContent><p>Thank you, <strong class=text-green-400 id=successUploaderName>Uploader</strong>!<p id=successSummaryText>Your overlay(s) are now live.<p class="text-sm text-gray-400 mt-3">Sharing helps the creative community grow!</div><div class="justify-center modal-buttons"><button type=button class=modal-button-confirm data-action=close-modal>Awesome!</button></div></div></div><div class=modal-backdrop id=termsModal><div class=modal-box><button type=button class=modal-close-btn data-action=close-modal aria-label="Close Terms Popup">×</button><h2><i class="fas mr-1 fa-file-contract"></i>Terms & Privacy</h2><div class=terms-content tabindex=0><h3>Terms and Conditions</h3><p><em>Last updated: 2024-05-16</em><p>Welcome to the Green Screen Vault! These terms and conditions outline the rules and regulations for the use of our website and services, located at [Your Website URL - Replace This]. By accessing this website, we assume you accept these terms and conditions. Do not continue to use Green Screen Vault if you do not agree to take all of the terms and conditions stated on this page.<h4>License (CC0)</h4><p>Unless otherwise stated, Green Screen Vault and/or its licensors own the intellectual property rights for original site design and functionality. <strong>User-uploaded content (videos) is licensed under Creative Commons Zero (CC0) - Public Domain Dedication upon successful upload.</strong> This means:<ul><li>You grant a worldwide, royalty-free, non-exclusive, perpetual, irrevocable license for others to download, copy, modify, distribute, perform, and use the content for any purpose, including commercial purposes, without asking permission from or providing attribution to the uploader or Green Screen Vault.<li>You warrant that you own the necessary rights to grant this license or that the content is already in the public domain and suitable for CC0 dedication. You affirm the content does not infringe on any third-party rights (copyright, trademark, privacy, etc.).</ul><h4>User Content and Conduct</h4><p>You are solely responsible for the content you upload. You agree not to upload content that:<ul><li>Is illegal, harmful, obscene, hateful, defamatory, threatening, infringing of intellectual property rights, invasive of privacy, or otherwise injurious or objectionable.<li>Contains software viruses, malware, political campaigning, commercial solicitation unrelated to the content itself, chain letters, mass mailings, or any form of "spam."<li>Depicts non-consensual sexual content, promotes illegal acts or extreme violence, or constitutes harassment.</ul><p>We reserve the right (but not the obligation) to remove or edit content that violates these terms or is otherwise deemed inappropriate, at our sole discretion, without notice.<h4>Deletion Password</h4><p>You must provide a deletion password upon upload. This password allows you (the uploader, from the same browser where the password was stored) to initiate the deletion process for your uploaded content. Keep this password secure and confidential. <strong>We are not responsible for lost passwords and cannot delete content without the correct password being provided through the site's interface. Passwords are stored only in your browser's local storage and are not recoverable by us.</strong><h4>Disclaimer</h4><p>The materials on Green Screen Vault's website are provided on an 'as is' basis. Green Screen Vault makes no warranties, expressed or implied, and hereby disclaims and negates all other warranties including, without limitation, implied warranties or conditions of merchantability, fitness for a particular purpose, or non-infringement of intellectual property or other violation of rights. Further, Green Screen Vault does not warrant or make any representations concerning the accuracy, likely results, or reliability of the use of the materials on its website or otherwise relating to such materials or on any sites linked to this site.<h4>Limitation of Liability</h4><p>In no event shall Green Screen Vault or its suppliers be liable for any damages (including, without limitation, damages for loss of data or profit, or due to business interruption) arising out of the use or inability to use the materials on Green Screen Vault's website, even if Green Screen Vault or a Green Screen Vault authorized representative has been notified orally or in writing of the possibility of such damage.<h4>Governing Law</h4><p>These terms and conditions are governed by and construed in accordance with the laws of [Your Jurisdiction, e.g., California, USA - Replace This] and you irrevocably submit to the exclusive jurisdiction of the courts in that State or location.<h4>Changes to Terms</h4><p>We reserve the right to revise these terms at any time. By using this website you are expected to review these terms on a regular basis.<hr class="border-gray-600 dark:border-gray-700 my-6"><h3>Privacy Policy</h3><p><em>Effective Date: 2024-05-16</em><p>We value your privacy. This Privacy Policy explains how Green Screen Vault ("we", "us", "our") handles information when you use our website and services.<h4>Information We Collect</h4><ul><li><strong>Uploaded Content:</strong> Videos you choose to upload are processed and stored via Cloudinary and become publicly accessible under the CC0 license.<li><strong>Metadata:</strong> We may store metadata associated with uploads, such as the public ID provided by Cloudinary, the optional uploader name you provide, and any title you assign (if renaming is implemented server-side). This may be stored temporarily or in a simple database for listing purposes. **Download counts may also be stored server-side if implemented.**<li><strong>Deletion Password Reference (Local Storage):</strong> The deletion password you provide during upload is stored <strong>only</strong> in your web browser's local storage. It is never sent to or stored on our servers. It is linked to the upload's public ID within your browser.<li><strong>User Preferences (Local Storage):</strong> We use local storage to remember your theme preference (dark/light) and whether you have accepted the terms.<li><strong>Locally Stored Data (Local Storage):</strong> Renamed titles and uploader names associated with videos are also stored in your browser's local storage to persist your customizations across sessions on that specific browser.<li><strong>Analytics Data (Non-Personal):</strong> We may collect anonymous usage data (e.g., page views, features used, general geographic location based on IP address) through standard web server logs or third-party analytics services (like Google Analytics, if implemented) to understand how the site is used and to improve it. This data is aggregated and does not personally identify you.<li><strong>Download Interaction Data (If Implemented):</strong> If download tracking is implemented, non-personally identifiable interaction data (e.g., which video ID was downloaded, timestamp) might be sent to the server to increment a counter. We would not link this directly to a specific user account (as there are none).</ul><h4>How We Use Information</h4><ul><li>To operate and display the website, including the video gallery and associated metadata (title, uploader, download count if implemented).<li>To enable the content deletion functionality using the password stored in *your* browser's local storage.<li>To remember your site preferences.<li>To analyze usage patterns and improve the website's functionality, content, and user experience.<li>To monitor for and prevent violations of our Terms and Conditions.<li>To track aggregated content popularity (e.g., download counts) if implemented.</ul><h4>Data Storage & Security</h4><ul><li>Videos are hosted and delivered by Cloudinary. Please refer to Cloudinary's Privacy Policy for their data practices.<li>Metadata required for listing (and download counts if implemented) might be stored on our server infrastructure. We take reasonable measures to protect this data, but no system is 100% secure.<li><strong>Deletion passwords, user preferences, renamed titles, and associated uploader names are stored only in your browser's local storage. Clearing your browser's data will permanently remove this information, including any stored deletion passwords, making deletion impossible via the website interface.</strong></ul><h4>Third-Party Services</h4><ul><li><strong>Cloudinary:</strong> Used for video hosting, processing, and delivery.<li><strong>Analytics Providers (Optional):</strong> If used (e.g., Google Analytics), they collect data according to their own privacy policies.<li><strong>Advertising Partners (Optional):</strong> If ads are implemented (e.g., Google AdSense), these partners may use cookies and web beacons to collect information for ad personalization and measurement. Refer to their respective privacy policies.</ul><h4>Cookies and Local Storage</h4><p>We use local storage as described above. We may use essential cookies for site functionality. If third-party services (analytics, ads) are used, they may set their own cookies. You can manage cookies and local storage through your browser settings.<h4>Your Rights and Choices</h4><p>You can delete your uploaded content using the deletion password via the site interface, provided the password exists in your current browser's local storage. You can clear your browser's local storage at any time to remove stored preferences, titles, names, and passwords. You can manage cookie preferences through your browser.<h4>Children's Privacy</h4><p>Our service is not directed to individuals under the age of 13 (or a higher age threshold depending on jurisdiction). We do not knowingly collect personal information from children. If we become aware that a child has provided us with information without parental consent, we take steps to remove such information.<h4>Policy Changes</h4><p>We may update this Privacy Policy from time to time. We will notify you of significant changes by posting the new policy on this page and updating the "Effective Date." We encourage you to review this policy periodically.<h4>Contact Us</h4><p>If you have any questions about this Privacy Policy, please contact us via the method provided in the "Contact Us" link in the footer.</div><label class="mt-4 terms-accept-label"id=termsAcceptWrapper style=display:none><input id=termsAcceptCheckbox class=mr-2 type=checkbox> <span>I have read and agree to the Terms and Conditions and Privacy Policy.</span></label><p class=modal-error id=termsError aria-live=assertive><div class=modal-buttons><button type=button class=modal-button-confirm id=termsAcceptBtn style=display:none>Agree & Continue</button> <button type=button class=modal-button-cancel data-action=close-modal id=termsCloseBtn>Close</button></div></div></div><div class=modal-backdrop id=aboutModal><div class=modal-box><button type=button class=modal-close-btn data-action=close-modal aria-label="Close About Us Popup">×</button><h2><i class="fas mr-2 text-blue-400 fa-users"aria-hidden=true></i>About Us</h2><div class="my-5 px-2 leading-relaxed text-left"><p class=mb-4>Hey there! We're the team behind the <strong>Green Screen Vault</strong>.<p class=mb-4>We're a passionate group of video editors and creators who noticed a need for a simple, free, and community-driven resource for high-quality green screen assets. That's why we built this Vault – a place to easily find, download, and share awesome chroma key clips for all kinds of projects.<p class=mb-4>Beyond running this site, we're also <strong>professional video editors</strong>! We love bringing stories to life and crafting visually stunning content. If you need help with your next video project, whether it's a complex edit, motion graphics, or just polishing up your footage, we're here to help.<p>Get in touch for editing inquiries: <a class="transition-colors underline hover:text-blue-300 text-blue-400"href=mailto:coolestvideoeditor@gmail.com>coolestvideoeditor@gmail.com</a><p class="text-sm text-gray-400 mt-4">For general site questions or feedback, please use the Contact Us link.</div><div class="justify-center modal-buttons"><button type=button class=modal-button-cancel data-action=close-modal>Close</button></div></div></div><div class=modal-backdrop id=contactModal><div class=modal-box><button type=button class=modal-close-btn data-action=close-modal aria-label="Close Contact Us Popup">×</button><h2><i class="fas mr-2 fa-envelope text-purple-400"aria-hidden=true></i>Contact Us</h2><div class="my-5 px-2 text-center"><p class=mb-4>Got questions, feedback, suggestions, or found a bug? We'd love to hear from you!<p class=mb-2>Maybe you have a brilliant idea for a new feature, or perhaps you just want to say hi (we like those too!).<p class=mt-5>Reach out directly via email:<p class="font-semibold mt-2 text-lg"><a class="transition-colors underline hover:scale-105 hover:text-purple-300 inline-block text-purple-400"href=mailto:ganeshvb003@gmail.com><i class="fas mr-2 fa-paper-plane hover:rotate-12 inline-block transition-transform"></i>ganeshvb003@gmail.com</a><p class="text-sm text-gray-400 mt-5">We'll do our best to get back to you soon!<p class="text-sm text-gray-400 mt-1">(For video editing service inquiries, please see the 'About Us' section.)</div><div class="justify-center modal-buttons"><button type=button class=modal-button-cancel data-action=close-modal>Close</button></div></div></div><footer class=site-footer><p>© <span id=currentYear></span> Green Screen Vault. Community driven & CC0 Licensed Content.<div class=footer-links><span class=footer-link id=showAboutLink title="Learn more about this project">About Us</span> <span class="text-gray-500 dark:text-gray-600"aria-hidden=true>|</span> <span class=footer-link id=viewTermsLink title="View Terms and Conditions & Privacy Policy">Terms & Privacy</span> <span class="text-gray-500 dark:text-gray-600"aria-hidden=true>|</span> <span class=footer-link id=showContactLink title="Get in touch">Contact Us</span></div></footer><script>// --- Global Constants & State ---
        // =====================================================================
        // === IMPORTANT: CONFIGURE YOUR CLOUDINARY ACCOUNT DETAILS HERE ===
        // =====================================================================
        const CLOUD_NAME = 'dogxcu1sj'; // *** REPLACE WITH YOUR Cloudinary Cloud Name ***
        const UPLOAD_PRESET = 'gs_overlay'; // *** REPLACE WITH The EXACT name of your UNSIGNED Upload Preset ***
        // =====================================================================
        // === IMPORTANT: BACKEND ENDPOINT CONFIGURATION ===
        // =====================================================================
        // Replace these with your actual backend API endpoints if you build one.
        // If you don't have a backend, fetching/deleting/download counts will rely
        // heavily on local storage and won't persist across sessions or be accurate globally.
        const VIDEO_FETCH_ENDPOINT = '/videos'; // Endpoint to get the list of all videos (e.g., from a database)
        const VIDEO_DELETE_ENDPOINT_BASE = '/delete'; // Base endpoint for deleting a video (e.g., /delete/:public_id)
        // Endpoint to track downloads - **REQUIRED** for accurate 'Popular' sort and display
        const DOWNLOAD_INCREMENT_ENDPOINT_BASE = '/increment_download'; // Example: /increment_download/:public_id (must be implemented on backend)
        // =====================================================================

        const VIDEOS_PER_LOAD = 12; // How many videos to load per batch
        let allVideos = []; // Holds all fetched video data (ideally from backend)
        let displayedVideos = []; // Holds the currently sorted/filtered videos for display
        let currentVideoIndex = 0; // Index for pagination within displayedVideos
        let renamedTitles = {}; // Key: public_id, Value: user-set title (localStorage)
        let uploaderNames = {}; // Key: public_id, Value: user-set name (localStorage)
        let currentFilter = 'recent'; // Default filter state
        let currentSearchQuery = ''; // Default search state
        let currentPromptCallback = null; // Callback for the generic prompt modal
        let isFetching = false; // Flag to prevent multiple fetches
        let successfulUploads = []; // Array to hold results for multiple uploads

        // --- Utility Functions ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        const log = (...args) => console.log('[GSV]', ...args);
        const err = (...args) => console.error('[GSV ERROR]', ...args);

        function safeGetElementById(id) {
            const el = document.getElementById(id);
            // Removed error logging here to avoid console spam if called before element exists
            return el;
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => { clearTimeout(timeout); func(...args); };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- Modal Management ---
        function showModal(modalId) {
            log(`Showing modal: ${modalId}`);
            const modal = safeGetElementById(modalId);
            if (modal && modal.classList.contains('modal-backdrop')) {
                modal.style.display = 'flex';
                // Basic focus trapping: focus the first interactive element or the modal box itself
                const focusableElement = modal.querySelector('button:not([disabled]), input:not([disabled]), [tabindex="0"], a[href]');
                const modalBox = modal.querySelector('.modal-box');
                if (focusableElement) {
                    // Delay focus slightly to allow animation to start
                    setTimeout(() => focusableElement.focus(), 50);
                } else if (modalBox) {
                    modalBox.setAttribute('tabindex', '-1'); // Make it focusable if no interactive elements found
                    setTimeout(() => modalBox.focus(), 50);
                }
                 // document.body.style.overflow = 'hidden'; // Consider implications if enabling
            } else {
                 err(`Cannot show modal - Element ${modalId} not found or not a modal backdrop.`);
            }
        }

        function hideModal(modalId) {
            log(`Hiding modal: ${modalId}`);
            const modal = safeGetElementById(modalId);
            if (modal && modal.classList.contains('modal-backdrop') && modal.style.display !== 'none') {
                 modal.classList.add('modal-fade-out');
                 // document.body.style.overflow = ''; // Re-enable if disabled

                // Use setTimeout matching animation duration + slight buffer
                setTimeout(() => {
                    if (modal) { // Check again in case it was removed quickly
                        modal.style.display = 'none';
                        modal.classList.remove('modal-fade-out');
                        const errorEl = modal.querySelector('.modal-error');
                        if (errorEl) errorEl.textContent = ''; errorEl.style.display = 'none'; // Also hide error field
                        // Remove temporary tabindex if added
                        const modalBox = modal.querySelector('.modal-box[tabindex="-1"]');
                        if(modalBox) modalBox.removeAttribute('tabindex');
                    }
                }, 350); // Match CSS animation duration + buffer
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            log("DOM Ready. Initializing...");
            try {
                initializeTheme(); // Set theme early
                loadLocalData();
                setupStaticEventListeners();
                handleIntro(); // Starts the flow: Intro -> Terms Check -> Initialize Page
            } catch (error) {
                err("Initialization failed:", error);
                const gallery = safeGetElementById('gallery');
                if (gallery) displayGalleryMessage('❌ Error loading page. Please refresh.', 'error');
            }
        });

        function loadLocalData() {
            log("Loading data from localStorage...");
            try {
                renamedTitles = JSON.parse(localStorage.getItem('renamedTitles') || '{}');
                uploaderNames = JSON.parse(localStorage.getItem('uploaderNames') || '{}');
                log(`Loaded ${Object.keys(renamedTitles).length} renamed titles, ${Object.keys(uploaderNames).length} uploader names.`);
            } catch (e) {
                err("Failed to parse localStorage data:", e);
                renamedTitles = {};
                uploaderNames = {};
                // Optionally clear corrupted data:
                // localStorage.removeItem('renamedTitles');
                // localStorage.removeItem('uploaderNames');
            }
        }

        function setupStaticEventListeners() {
            log("Setting up static event listeners...");
            const galleryElement = safeGetElementById('gallery');
            const themeToggleBtn = safeGetElementById('themeToggleBtn');
            const showUploadBtn = safeGetElementById('showUploadBtn');
            const scrollToUploadLink = safeGetElementById('scrollToUpload');
            const searchInput = safeGetElementById('search');
            const loadMoreBtn = safeGetElementById('loadMoreBtn');
            const viewTermsLink = safeGetElementById('viewTermsLink');
            const showAboutLink = safeGetElementById('showAboutLink');
            const showContactLink = safeGetElementById('showContactLink');
            const selectUploadBtn = safeGetElementById('selectUploadBtn');
            const termsAcceptBtn = safeGetElementById('termsAcceptBtn');

            // Header Buttons
            if (themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);
            if (showUploadBtn) showUploadBtn.addEventListener('click', () => {
                // Reset upload form on open
                successfulUploads = []; // Clear any previous upload results
                const uploaderInput = safeGetElementById('uploaderNameInput');
                const passInput = safeGetElementById('deletePassword');
                const status = safeGetElementById('uploadStatus');
                const progressContainer = safeGetElementById('progressContainer');
                const uploadButton = safeGetElementById('selectUploadBtn'); // Ensure button is re-enabled
                if(uploaderInput) uploaderInput.value = '';
                if(passInput) passInput.value = '';
                if(status) status.textContent = '';
                if(progressContainer) {
                    progressContainer.style.display = 'none';
                    const progressBar = safeGetElementById('progressBar');
                    if(progressBar) progressBar.style.width = '0%';
                }
                if (uploadButton) uploadButton.disabled = false; // Re-enable on open
                showModal('uploadPopup');
            });

            // Scroll to Upload CTA
            if (scrollToUploadLink && showUploadBtn) {
                scrollToUploadLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    showUploadBtn.click(); // Trigger the upload button click
                    safeGetElementById('uploadPopup')?.querySelector('input, button')?.focus(); // Focus first element in modal
                });
            }

            // Search Input (Debounced)
            if (searchInput) {
                searchInput.addEventListener('input', debounce(() => {
                    const query = searchInput.value.toLowerCase().trim();
                    if (query !== currentSearchQuery) {
                        log(`Search updated to: "${query}"`);
                        currentSearchQuery = query;
                        applyFiltersAndRender(true); // Reset and search/filter
                    }
                }, 400));
            }

            // Filter Buttons
            $$('.filter-options .filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const filterType = e.target.dataset.filter;
                    if (filterType && filterType !== currentFilter) {
                        currentFilter = filterType;
                        setActiveFilterButton(e.target); // Update style immediately
                        applyFiltersAndRender(true); // Reset and filter/search
                    } else if (!filterType) {
                        err("Filter button missing data-filter attribute:", e.target);
                    }
                });
            });

            // Load More Button
            if (loadMoreBtn) loadMoreBtn.addEventListener('click', () => renderVideoBatch(false)); // false means continue rendering

            // Footer Links (Modals)
            if (viewTermsLink) viewTermsLink.addEventListener('click', () => showTermsModal(true)); // true = viewing only
            if (showAboutLink) showAboutLink.addEventListener('click', () => showModal('aboutModal'));
            if (showContactLink) showContactLink.addEventListener('click', () => showModal('contactModal'));

            // Modal Close/Action Buttons (using event delegation on document)
            document.addEventListener('click', (event) => {
                const target = event.target;

                // Generic modal close (button or backdrop click)
                 const modalBackdrop = target.closest('.modal-backdrop');
                 const closeAction = target.closest('[data-action="close-modal"]');
                 // If clicked on backdrop directly OR on a button with data-action="close-modal"
                 if (target.classList.contains('modal-backdrop') || closeAction) {
                    if(modalBackdrop) hideModal(modalBackdrop.id);
                 }

                 // Prompt modal specific close action
                 const closePromptAction = target.closest('[data-action="close-prompt"]');
                 if (closePromptAction) {
                    hideModal('promptModal');
                 }

                 // Close action popups if clicked outside
                const openPopup = document.querySelector('.action-popup[style*="display: block"]');
                if (openPopup && !openPopup.contains(target) && !target.closest('.menu-btn')) {
                    log("Clicked outside, closing action menu:", openPopup.id);
                    openPopup.style.display = 'none';
                     const menuButton = $(`button[aria-controls="${openPopup.id}"]`);
                     if(menuButton) menuButton.setAttribute('aria-expanded', 'false');
                }
            });

            // Upload Modal Specific Buttons
             if (selectUploadBtn) selectUploadBtn.addEventListener('click', openCloudinaryUpload);
             if (termsAcceptBtn) termsAcceptBtn.addEventListener('click', acceptTerms);

             // Prompt modal confirm is handled within showPromptModal setup

             // Gallery Event Listener (Delegation for play/menu/actions/download)
             if (galleryElement) {
                 galleryElement.addEventListener('click', handleGalleryClick);
             }

            log("Static event listeners set up.");
        }

        function handleGalleryClick(event) {
             const target = event.target;
             const card = target.closest('.card');
             const publicId = card?.dataset.publicId;

             // Video Play/Pause
             const videoContainer = target.closest('.video-container');
             if (videoContainer && publicId) {
                 const video = videoContainer.querySelector('video');
                 if(video) togglePlay(video);
                 event.stopPropagation(); // Prevent other clicks if video container clicked
                 return; // Handled
             }

             // Menu Button Click
             const menuButton = target.closest('.menu-btn');
             if (menuButton && publicId) {
                 toggleActionMenu(publicId, menuButton); // Pass button to position popup
                 event.stopPropagation(); // Prevent other clicks if menu button clicked
                 return; // Handled
             }

             // Action Popup Button Click (Rename/Delete)
             const actionButton = target.closest('.action-popup button');
             if (actionButton && publicId) {
                 // Hide the popup immediately
                 const popup = actionButton.closest('.action-popup');
                 if (popup) popup.style.display = 'none';
                 const parentMenuButton = $(`button[aria-controls="${popup?.id}"]`); // Added optional chaining for safety
                 if(parentMenuButton) parentMenuButton.setAttribute('aria-expanded', 'false');

                 if (actionButton.textContent.includes('Rename')) {
                    triggerRename(publicId);
                 } else if (actionButton.classList.contains('delete-action')) {
                    triggerDelete(publicId);
                 }
                 event.stopPropagation(); // Prevent other clicks if action button clicked
                 return; // Handled
             }

             // Download Button Click (for triggering count increment - download itself is handled by <a> tag)
             const downloadBtn = target.closest('.download-btn');
             if (downloadBtn && publicId) {
                log(`Download button clicked for ${publicId}. Triggering count increment (if backend exists).`);

                // --- DOWNLOAD COUNT INCREMENT (Requires Backend) ---
                if (DOWNLOAD_INCREMENT_ENDPOINT_BASE) {
                    const incrementUrl = `${DOWNLOAD_INCREMENT_ENDPOINT_BASE}/${encodeURIComponent(publicId)}`;
                    log(`Sending download increment request to: ${incrementUrl}`);
                    // Use sendBeacon or fetch with keepalive for better reliability if user navigates away
                    if (navigator.sendBeacon) {
                         navigator.sendBeacon(incrementUrl);
                         log(`Sent beacon for download increment: ${publicId}`);
                    } else {
                        fetch(incrementUrl, { method: 'POST', cache: 'no-store', keepalive: true })
                            .then(response => {
                                if (!response.ok) log(`Failed to increment download count for ${publicId} (status: ${response.status})`);
                                else log(`Increment request succeeded for ${publicId}`);
                                // OPTIONALLY update count in UI immediately (Optimistic Update)
                                // const countEl = card?.querySelector('.download-count');
                                // if (countEl) {
                                //    const currentCountText = countEl.textContent || '0';
                                //    const currentCount = parseInt(currentCountText.replace(/[^0-9]/g, ''), 10) || 0;
                                //    const newCount = currentCount + 1;
                                //    countEl.innerHTML = `<i class="fas fa-download" aria-hidden="true"></i> ${newCount.toLocaleString()}`;
                                //    countEl.title = `${newCount.toLocaleString()} downloads`;
                                //    // Update the underlying data if needed, though fetchAndRenderVideos is safer
                                //    const videoData = allVideos.find(v => v.public_id === publicId);
                                //    if(videoData) videoData.download_count = newCount;
                                // }
                            })
                            .catch(fetchErr => err(`Error sending download increment for ${publicId}:`, fetchErr)); // Corrected variable name
                    }
                } else {
                     log("Download increment endpoint not configured, skipping count update.");
                }
                // NOTE: Do NOT prevent the default link behavior here. The actual file
                // download is handled by the browser via the href/download attributes on the <a> tag.
             }
        }


        // --- Intro & Terms Flow ---
        function handleIntro() {
            log("Starting intro...");
            const introScreen = safeGetElementById('introScreen');
            if (!introScreen || introScreen.classList.contains('fade-out')) {
                log("Intro screen skipped or already faded.");
                checkTerms(); return;
            }
            // Use timeout matching the animation + transition delays in CSS
            setTimeout(() => {
                log("Fading intro out.");
                if (introScreen) {
                    introScreen.classList.add('fade-out');
                    introScreen.addEventListener('transitionend', (e) => {
                        // Ensure we only react to the opacity transition ending
                        if (e.propertyName === 'opacity' && introScreen.classList.contains('fade-out')) {
                             checkTerms();
                         }
                    }, { once: true });
                 } else { checkTerms(); } // Fallback if introScreen disappears unexpectedly
            }, 2800); // Adjust time (animation + delay + pause)
        }

        function checkTerms() {
            log("Checking terms acceptance...");
            if (localStorage.getItem('termsAccepted') !== 'true') {
                log("Terms not accepted, showing modal.");
                showTermsModal(false); // false = require acceptance
            } else {
                log("Terms accepted, initializing page.");
                initializePage();
            }
        }

        function showTermsModal(isViewingOnly = false) {
             log(`Show terms modal (view only: ${isViewingOnly})`);
             const modal = safeGetElementById('termsModal');
             const acceptWrapper = safeGetElementById('termsAcceptWrapper');
             const acceptBtn = safeGetElementById('termsAcceptBtn');
             const closeBtn = safeGetElementById('termsCloseBtn'); // Now always acts as close/disagree
             const errorMsg = safeGetElementById('termsError');
             if (!modal || !acceptWrapper || !acceptBtn || !closeBtn || !errorMsg) {
                 err("One or more terms modal elements not found.");
                 return;
             }

             errorMsg.textContent = '';
             const checkbox = safeGetElementById('termsAcceptCheckbox');
             if (checkbox) checkbox.checked = false;

             acceptWrapper.style.display = isViewingOnly ? 'none' : 'flex';
             acceptBtn.style.display = isViewingOnly ? 'none' : 'inline-flex';
             closeBtn.textContent = isViewingOnly ? 'Close' : 'Disagree'; // Change button text
             acceptBtn.disabled = false; // Re-enable button if it was disabled

             showModal('termsModal');
             safeGetElementById('termsModal')?.querySelector('.terms-content')?.focus(); // Focus content for scrolling
        }

        function acceptTerms() {
            log("Accept terms clicked.");
            const checkbox = safeGetElementById('termsAcceptCheckbox');
            const errorMsg = safeGetElementById('termsError');
            const acceptBtn = safeGetElementById('termsAcceptBtn');
            if (!checkbox || !errorMsg || !acceptBtn) return;

            acceptBtn.disabled = true; // Prevent double click

            if (checkbox.checked) {
                log("Terms accepted by user.");
                localStorage.setItem('termsAccepted', 'true');
                hideModal('termsModal');
                initializePage(); // Initialize after acceptance
            } else {
                errorMsg.textContent = 'Please check the box to accept the terms and conditions.';
                 acceptBtn.disabled = false; // Re-enable if not accepted
            }
        }

        // --- Main Page Initialization ---
        function initializePage() {
            log("Initializing main page.");
            setActiveFilterButton(); // Set initial active filter button style
            updateFooterYear();
            fetchAndRenderVideos(); // Initial video fetch and render
            log("Main page initialized.");
        }

        function updateFooterYear() {
            const yearSpan = safeGetElementById('currentYear');
            if (yearSpan) yearSpan.textContent = new Date().getFullYear();
        }

        // --- Modal Helpers (Generic Prompt) ---
        function showPromptModal({ title, contentHTML = '', inputLabel = '', inputType = 'text', placeholder = '', confirmText = 'Confirm', cancelText = 'Cancel', callback, initialValue = '', isConfirmation = false, confirmClass = '' }) {
            log(`Showing prompt modal: "${title}" (isConfirmation: ${isConfirmation})`);
            const modalId = 'promptModal';
            const titleEl = safeGetElementById('promptTitle');
            const contentDiv = safeGetElementById('promptContent');
            const confirmBtn = safeGetElementById('promptConfirmBtn');
            const cancelBtn = safeGetElementById('promptCancelBtn');
            const errorEl = safeGetElementById('promptError');

            if (!titleEl || !contentDiv || !confirmBtn || !cancelBtn || !errorEl) {
                err("Prompt modal elements missing.");
                return;
            }

            // Reset common elements
            titleEl.innerHTML = title; // Allow icons in title
            contentDiv.innerHTML = ''; // Clear previous dynamic content
            errorEl.innerText = ''; // Clear previous error text
            errorEl.style.display = 'none'; // Hide error initially
            contentDiv.appendChild(errorEl); // Ensure error element is part of the content div structure

            // Set button classes and text
            confirmBtn.className = 'modal-button-confirm'; // Reset to base confirm class first
             if (confirmClass) {
                 confirmBtn.classList.add(...confirmClass.split(' ')); // Apply specific classes (like delete)
             }
            confirmBtn.textContent = confirmText;
            cancelBtn.textContent = cancelText;

            let inputEl = null; // Variable to hold the input element if created

            if (isConfirmation) {
                log("Setting up prompt as confirmation.");
                // Display confirmation text
                const p = document.createElement('p');
                p.innerHTML = contentHTML; // Use innerHTML to allow basic formatting
                contentDiv.insertBefore(p, errorEl); // Insert confirmation text before error message
            } else {
                 log("Setting up prompt with input.");
                 // Display any static HTML content provided
                 if(contentHTML) {
                    const staticContent = document.createElement('div');
                    staticContent.innerHTML = contentHTML;
                    contentDiv.insertBefore(staticContent, errorEl);
                 }
                 // Create label and input field
                 const labelEl = document.createElement('label');
                 labelEl.htmlFor = 'promptInput';
                 labelEl.innerText = inputLabel;
                 labelEl.className = 'block mb-2 font-semibold text-sm';

                 inputEl = document.createElement('input'); // Assign to inputEl
                 inputEl.type = inputType;
                 inputEl.id = 'promptInput';
                 inputEl.placeholder = placeholder;
                 inputEl.value = initialValue;
                 const theme = document.documentElement.getAttribute('data-theme') || 'dark';
                 const baseInputClasses = "w-full p-3 rounded-lg border transition-colors duration-200 focus:outline-none focus:ring-2 mb-1";
                 const themeInputClasses = theme === 'light'
                    ? "bg-gray-100 border-gray-300 text-gray-900 focus:border-blue-400 focus:ring-blue-200"
                    : "bg-gray-700 border-gray-600 text-white focus:border-blue-500 focus:ring-blue-400 focus:ring-opacity-50";
                 inputEl.className = `${baseInputClasses} ${themeInputClasses}`;
                 inputEl.setAttribute('aria-label', inputLabel); // Add aria-label for screen readers

                 contentDiv.insertBefore(labelEl, errorEl);
                 contentDiv.insertBefore(inputEl, errorEl);
            }

            currentPromptCallback = callback; // Store the callback

            // Re-attach event listener using cloning to prevent multiple callbacks stacking up
            const newConfirmBtn = confirmBtn.cloneNode(true); // Clone to remove old listeners
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            safeGetElementById('promptConfirmBtn').addEventListener('click', handlePromptConfirm);

            // Ensure cancel button uses data-action for consistency
            const newCancelBtn = cancelBtn.cloneNode(true);
            newCancelBtn.setAttribute('data-action', 'close-prompt'); // Use data-action
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            showModal(modalId); // Show the configured modal

            // Focus logic
            if (inputEl) {
                log("Focusing prompt input.");
                setTimeout(() => inputEl.focus(), 100); // Delay focus slightly
            } else if (isConfirmation) {
                log("Focusing prompt confirm button.");
                setTimeout(() => safeGetElementById('promptConfirmBtn')?.focus(), 100); // Focus confirm for confirmations
            }
        }


        function handlePromptConfirm() {
            log("Prompt confirm button clicked.");
            if (currentPromptCallback) {
                const input = safeGetElementById('promptInput');
                const value = input ? input.value : true; // Pass true for confirmation prompts without input
                log("Executing prompt callback with value:", input ? '(input value)' : value);
                currentPromptCallback(value); // Execute the stored callback
                // Let the callback decide whether to hide the modal or show an error
            } else {
                err("No callback registered for prompt confirmation.");
                hidePromptModal(); // Close anyway if no callback found
            }
        }

        function hidePromptModal() {
            hideModal('promptModal');
            currentPromptCallback = null; // Clear callback when closing
        }

         function showPromptError(message) {
            log("Showing prompt error:", message);
            const errorElement = safeGetElementById('promptError');
            if (errorElement) {
                errorElement.innerText = message;
                errorElement.style.display = message ? 'block' : 'none'; // Show only if message exists
            } else {
                err("Cannot show prompt error, element #promptError not found.");
            }
        }

         function showUploadSuccessPopup(uploaderName, count) {
            log(`Showing success popup for ${count} uploads by ${uploaderName}`);
            const uploaderSpan = safeGetElementById('successUploaderName');
            const summaryText = safeGetElementById('successSummaryText');

            if (uploaderSpan) uploaderSpan.innerText = uploaderName || 'Anonymous';
            if (summaryText) {
                summaryText.innerText = count === 1
                    ? 'Your overlay is now live.'
                    : `Your ${count} overlays are now live.`;
            }
            showModal('uploadSuccessPopup');
        }


        // --- Theme Toggle ---
         function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            log(`Initializing theme: ${savedTheme}`);
            document.documentElement.setAttribute('data-theme', savedTheme);
            // Apply initial filter button styles based on loaded theme
             setActiveFilterButton();
        }

        function toggleTheme() {
             const html = document.documentElement;
             const currentTheme = html.getAttribute('data-theme') || 'dark';
             const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
             log(`Toggling theme from ${currentTheme} to ${newTheme}`);
             html.setAttribute('data-theme', newTheme);
             localStorage.setItem('theme', newTheme);
             setActiveFilterButton(); // Update filter button style immediately
             // Update Prompt Modal input style if visible
             const promptInput = safeGetElementById('promptInput');
             if (promptInput && safeGetElementById('promptModal')?.style.display === 'flex') {
                  const baseInputClasses = "w-full p-3 rounded-lg border transition-colors duration-200 focus:outline-none focus:ring-2 mb-1";
                  const themeInputClasses = newTheme === 'light'
                    ? "bg-gray-100 border-gray-300 text-gray-900 focus:border-blue-400 focus:ring-blue-200"
                    : "bg-gray-700 border-gray-600 text-white focus:border-blue-500 focus:ring-blue-400 focus:ring-opacity-50";
                 promptInput.className = `${baseInputClasses} ${themeInputClasses}`;
             }
             // Update Cloudinary widget theme if open (optional, requires storing widget instance)
             // if (window.cloudinaryWidgetInstance) { window.cloudinaryWidgetInstance.update({ theme: newTheme }); }
        }

        // --- Upload Logic (Modified for Multiple Files) ---
        function openCloudinaryUpload() {
            log("Initiating Cloudinary upload process (multiple enabled)...");
            const uploaderNameInput = safeGetElementById('uploaderNameInput');
            const delPassInput = safeGetElementById('deletePassword');
            const progressBar = safeGetElementById('progressBar');
            const progressContainer = safeGetElementById('progressContainer');
            const status = safeGetElementById('uploadStatus');
            const uploadButton = safeGetElementById('selectUploadBtn');

            if (!uploaderNameInput || !delPassInput || !progressBar || !progressContainer || !status || !uploadButton) {
                err("Upload modal elements missing.");
                if(status) status.innerText = '❌ Internal error: Missing form elements.';
                return;
            }
             if (!CLOUD_NAME || !UPLOAD_PRESET) {
                 err("Cloudinary CLOUD_NAME or UPLOAD_PRESET is not configured in the script.");
                 status.innerText = '❌ Configuration Error: Cloudinary details missing.';
                 return;
             }

            const uploaderName = uploaderNameInput.value.trim() || 'Anonymous';
            const delPass = delPassInput.value.trim();

            if (!delPass) {
                status.innerText = "❌ Deletion password is required.";
                delPassInput.focus(); return;
            }
             if (delPass.length < 6) {
                 status.innerText = "❌ Password must be at least 6 characters.";
                 delPassInput.focus(); return;
             }

            status.innerText = 'Initializing widget...';
            progressBar.style.width = '0%';
            progressContainer.style.display = 'block';
            uploadButton.disabled = true; // Disable button during upload process
            successfulUploads = []; // Reset the array for this session

            try {
                // Ensure Cloudinary object exists
                 if (typeof cloudinary === 'undefined' || typeof cloudinary.openUploadWidget !== 'function') {
                     throw new Error("Cloudinary script not loaded or invalid.");
                 }

                 const widget = cloudinary.openUploadWidget({
                    cloudName: CLOUD_NAME, uploadPreset: UPLOAD_PRESET,
                    sources: ['local', 'url', 'camera', 'dropbox', 'google_drive'],
                    resourceType: 'video',
                    multiple: true, // *** ENABLED MULTIPLE UPLOADS ***
                    clientAllowedFormats: ['mp4', 'webm', 'mov'], // Common web video formats
                    // maxFileSize: 300000000, // *** REMOVED CLIENT-SIDE LIMIT *** Cloudinary account limits still apply!
                    folder: 'gs_overlay', // Optional: organize uploads in Cloudinary
                    theme: document.documentElement.getAttribute("data-theme") || "dark" // Match site theme
                }, (error, result) => {
                    // Re-select elements within callback scope to ensure they exist
                    const currentUploadButton = safeGetElementById('selectUploadBtn');
                    const currentStatus = safeGetElementById('uploadStatus');
                    const currentProgressBar = safeGetElementById('progressBar');
                    const currentProgressContainer = safeGetElementById('progressContainer');

                    if (error) {
                        err("Cloudinary Widget Error:", error);
                        if(currentStatus) currentStatus.innerText = `❌ Error: ${error.statusText || error.message || 'Upload failed'}`;
                        if(currentProgressContainer) currentProgressContainer.style.display = 'none';
                        if(currentUploadButton) currentUploadButton.disabled = false; // Re-enable on error
                        successfulUploads = []; // Clear array on error
                    } else if (result && result.event) {
                        log("Cloudinary Event:", result.event, result.info || '');
                        switch (result.event) {
                            case "upload-added":
                                if(currentStatus) currentStatus.innerText = `Adding file(s)...`;
                                if (currentProgressBar) currentProgressBar.style.width = `0%`; // Reset progress for new file
                                if(currentProgressContainer) currentProgressContainer.style.display = 'block'; // Ensure visible
                                break;
                            case "uploadprogress":
                                if (result.info && typeof result.info.bytes_uploaded === 'number' && result.info.total_bytes) {
                                    const percent = Math.round((result.info.bytes_uploaded / result.info.total_bytes) * 100);
                                    if (currentProgressBar) {
                                        currentProgressBar.style.width = `${percent}%`;
                                        currentProgressBar.setAttribute('aria-valuenow', percent);
                                    }
                                    // Show progress for the *current* file being uploaded
                                    const filename = result.info.original_filename || 'current file';
                                    if(currentStatus) currentStatus.innerText = `Uploading ${filename}... ${percent}%`;
                                } else {
                                    if(currentStatus) currentStatus.innerText = `Uploading...`; // Fallback if byte info missing
                                }
                                break;
                            case "success":
                                log("Cloudinary Success (single file):", result.info);
                                if (!result.info?.public_id || !result.info?.secure_url) {
                                     err("Cloudinary success event missing critical data:", result.info);
                                     if(currentStatus) currentStatus.innerText = `❌ Error: Upload data incomplete for one file.`;
                                     // Don't stop other uploads, but log the issue
                                     return;
                                }
                                // Store result for later processing
                                successfulUploads.push(result.info);
                                if(currentStatus) currentStatus.innerText = `✅ ${successfulUploads.length} file(s) uploaded successfully. Finishing...`;
                                if (currentProgressBar) {
                                    currentProgressBar.style.width = '100%'; // Show complete for this file
                                    currentProgressBar.setAttribute('aria-valuenow', 100);
                                }
                                break;

                             case "close":
                                log("Cloudinary Widget Closed.");
                                handleMultipleUploadSuccess(uploaderName, delPass); // Process all successful uploads
                                // Reset UI elements in the upload modal, ready for next time
                                if (currentUploadButton) currentUploadButton.disabled = false;
                                // Status message handled by handleMultipleUploadSuccess or error cases
                                break;
                            case "abort": // User aborted upload
                            case "queue-too-large":
                            case "bytes-total-exceeded":
                            case "max-files-exceeded":
                                const eventText = result.event.replace(/-/g, ' '); // Make event name readable
                                err(`Cloudinary Upload Error: ${eventText}`, result.info || '');
                                if(currentStatus) currentStatus.innerText = `❌ Upload Error: ${eventText}`;
                                if(currentProgressContainer) currentProgressContainer.style.display = 'none';
                                if(currentUploadButton) currentUploadButton.disabled = false; // Re-enable on error
                                successfulUploads = []; // Clear array on error
                                break;
                            default:
                                // Log other events if needed for debugging
                                // log("Other Cloudinary event:", result.event);
                                break;
                        }
                    }
                });
            } catch (widgetError) {
                err("Error opening Cloudinary Widget:", widgetError);
                if(status) status.innerText = "❌ Failed to open upload widget. Script might be missing or misconfigured.";
                if(progressContainer) progressContainer.style.display = 'none';
                if (uploadButton) uploadButton.disabled = false; // Re-enable button
                successfulUploads = []; // Clear array on error
            }
        }

        function handleMultipleUploadSuccess(uploaderName, delPass) {
            log(`Processing ${successfulUploads.length} successful uploads.`);
            const currentStatus = safeGetElementById('uploadStatus');
            const currentProgressContainer = safeGetElementById('progressContainer');

            if (successfulUploads.length === 0) {
                log("No successful uploads to process.");
                // Optionally update status if it wasn't an explicit error before closing
                if (currentStatus && !currentStatus.innerText.includes('Error')) {
                     currentStatus.innerText = 'Widget closed or cancelled.';
                }
                 if(currentProgressContainer) currentProgressContainer.style.display = 'none';
                return;
            }

            const newVideoEntries = [];
            let localSaveError = false;

            try {
                successfulUploads.forEach(uploadInfo => {
                    const publicId = uploadInfo.public_id;
                    const originalFilename = uploadInfo.original_filename;
                    const secureUrl = uploadInfo.secure_url;

                    if (!publicId || !secureUrl) {
                        err("Skipping an upload due to missing data:", uploadInfo);
                        return; // Skip this iteration
                    }

                    // 1. Save password, uploader name, and original filename locally for EACH file
                    localStorage.setItem(`pass_${publicId}`, delPass);
                    uploaderNames[publicId] = uploaderName; // Add to the uploaderNames object
                     if (originalFilename) {
                         localStorage.setItem(`filename_${publicId}`, originalFilename);
                     }

                    // 2. Prepare data for the main video list
                    const newVideoData = {
                        public_id: publicId,
                        created_at: new Date().toISOString(), // Use current time
                        secure_url: secureUrl,
                        original_filename: originalFilename || null,
                        download_count: 0 // Default download count
                    };
                    newVideoEntries.push(newVideoData);
                });

                // 3. Save the *entire* updated uploaderNames object to localStorage *once*
                localStorage.setItem('uploaderNames', JSON.stringify(uploaderNames));
                log(`Passwords, uploader names, and filenames saved locally for ${newVideoEntries.length} uploads.`);

            } catch(e) {
                err("Error saving passwords/uploader names/filenames to localStorage:", e);
                 if(currentStatus) currentStatus.innerText = '✅ Uploaded, but failed to save some data locally!';
                localSaveError = true;
                 // Continue with adding to the list and refreshing UI
            }

            // 4. Add all new entries to the main video list (prepend to show newest first)
            allVideos.unshift(...newVideoEntries);
            log(`Added ${newVideoEntries.length} new videos to the main list.`);

            // 5. Refresh the gallery view
            applyFiltersAndRender(true); // Reset filters/pagination

            // 6. Hide upload modal and show success modal
            hideModal('uploadPopup');
            showUploadSuccessPopup(uploaderName, newVideoEntries.length);

            // Reset the successful uploads array
            successfulUploads = [];
        }


        // --- Filtering & Sorting ---
        function setActiveFilterButton(buttonElement = null) {
             const theme = document.documentElement.getAttribute("data-theme") || "dark";
             // Define classes clearly
             const baseClasses = {
                inactive: ['border-transparent', 'opacity-80', 'hover:opacity-100'],
                active: ['border-2', 'shadow-md', 'opacity-100', 'active-filter'] // Added active-filter class
             };
             const themeClasses = {
                 dark: {
                     inactive: ['bg-gray-600', 'text-gray-100', 'hover:bg-gray-500'],
                     active: ['bg-green-500', 'text-black', 'border-green-600', 'shadow-lg', 'shadow-green-500/30'] // Adjusted green
                 },
                 light: {
                     inactive: ['bg-gray-300', 'text-gray-700', 'hover:bg-gray-400'],
                     active: ['bg-indigo-600', 'text-white', 'border-indigo-700', 'shadow-lg', 'shadow-indigo-500/30'] // Adjusted indigo
                 }
             };
             const currentThemeClasses = theme === 'light' ? themeClasses.light : themeClasses.dark;
             // Combine all possible classes to ensure clean removal
             const allPossibleClasses = [
                 ...baseClasses.inactive, ...baseClasses.active,
                 ...themeClasses.dark.inactive, ...themeClasses.dark.active,
                 ...themeClasses.light.inactive, ...themeClasses.light.active,
                 'active-filter' // Ensure this is removable
             ].filter(c => c); // Filter out any potentially undefined classes

             if (!buttonElement) {
                 buttonElement = $(`.filter-options .filter-btn[data-filter="${currentFilter}"]`);
             }

             $$('.filter-options .filter-btn').forEach(btn => {
                 btn.classList.remove(...allPossibleClasses); // Remove all potential style classes first
                 btn.setAttribute('aria-selected', 'false');
                 // Apply the correct set of classes
                 if (btn === buttonElement) {
                     btn.classList.add(...baseClasses.active, ...currentThemeClasses.active);
                     btn.setAttribute('aria-selected', 'true');
                 } else {
                     btn.classList.add(...baseClasses.inactive, ...currentThemeClasses.inactive);
                 }
             });

             if(buttonElement) {
                 log(`Active filter button style set for ${currentFilter} on theme ${theme}`);
             } else {
                 log(`setActiveFilterButton called but could not find button for filter ${currentFilter}`);
                 // Attempt to style the default 'recent' button if it exists and matches the current filter
                 const defaultBtn = safeGetElementById('filter-recent');
                 if (defaultBtn && currentFilter === 'recent') {
                     defaultBtn.classList.remove(...allPossibleClasses); // Clean slate
                     defaultBtn.classList.add(...baseClasses.active, ...currentThemeClasses.active);
                     defaultBtn.setAttribute('aria-selected', 'true');
                      log(`Applied active style to default 'recent' button.`);
                 }
             }
        }

        // --- Video Loading, Filtering, Sorting & Rendering ---
        async function fetchAndRenderVideos() {
            if (isFetching) {
                log("Fetch already in progress, skipping.");
                return;
            }
            isFetching = true;
            log("Fetching initial video list...");
            const gallery = safeGetElementById("gallery");
            const loadMoreBtn = safeGetElementById('loadMoreBtn');

            if (!gallery || !loadMoreBtn) {
                err("Gallery or Load More button not found during fetch.");
                isFetching = false;
                return;
            }

            // Display loading message immediately
             displayGalleryMessage('🔄 Fetching video list...', 'info');
             loadMoreBtn.style.display = 'none';
             loadMoreBtn.disabled = true;

            // --- BACKEND REQUIRED ---
            // Fetch video data from your backend endpoint.
            // Expected JSON format: Array of objects, each with at least:
            // {
            //   "public_id": "string",
            //   "secure_url": "string_url",
            //   "created_at": "string_iso_date",
            //   "original_filename": "string_optional",
            //   "download_count": number_optional_but_needed_for_popular_sort
            // }
            try {
                log(`Fetching from endpoint: ${VIDEO_FETCH_ENDPOINT}`);
                const response = await fetch(VIDEO_FETCH_ENDPOINT, { cache: 'no-store' }); // Avoid caching issues

                if (!response.ok) {
                    // --- FRONTEND ONLY FALLBACK (Example - For testing without backend) ---
                    if (response.status === 404 && VIDEO_FETCH_ENDPOINT === '/videos') {
                         log("Backend endpoint '/videos' not found (404). Using localStorage videos only for this session (limited data).");
                         allVideos = Object.keys(localStorage)
                             .filter(key => key.startsWith('pass_'))
                             .map(key => {
                                 const publicId = key.substring(5);
                                 // Attempt to construct basic data. Missing secure_url and precise created_at!
                                 const storedFilename = localStorage.getItem(`filename_${publicId}`); // Retrieve stored filename
                                 return {
                                     public_id: publicId,
                                     // Guess secure_url - MAY BE INCORRECT if format/resource_type changes
                                     secure_url: `https://res.cloudinary.com/${CLOUD_NAME}/video/upload/${publicId}.mp4`,
                                     created_at: new Date(0).toISOString(), // Use epoch as placeholder
                                     original_filename: storedFilename || null, // Use stored filename
                                     download_count: 0 // Placeholder download count
                                 };
                             });
                        if (allVideos.length === 0) {
                             displayGalleryMessage('📪 No videos found locally! Be the first to upload.', 'empty');
                             isFetching = false;
                             return;
                         }
                         log(`Loaded ${allVideos.length} videos from localStorage (limited data, fallback mode).`);
                         clearGalleryMessages();
                         applyFiltersAndRender(true);
                         isFetching = false;
                         return; // Exit fetch block after handling fallback
                    }
                    // --- End Frontend Only Fallback ---

                    let errorMsg = `Server Error: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.message || errorData.details || errorData.error || errorMsg;
                        err("Server error details:", errorData);
                    } catch (e) {
                        log("Could not parse error response body:", e);
                        try {
                            const errorText = await response.text();
                            if (errorText) errorMsg += ` - ${errorText.substring(0, 100)}`;
                        } catch (textErr) { /* Ignore */ }
                    }
                    throw new Error(errorMsg);
                }

                allVideos = await response.json();

                if (!Array.isArray(allVideos)) {
                    err("Invalid data format received from server (expected an array).", allVideos);
                    throw new Error("Invalid data format received from server.");
                }
                log(`Fetched ${allVideos.length} total videos from backend.`);

                if (allVideos.length === 0) {
                     displayGalleryMessage('📪 No videos found yet! Be the first to upload.', 'empty');
                     isFetching = false;
                     return; // Stop here if no videos
                 }

                 // Success: Clear loading message and proceed
                 clearGalleryMessages();
                 applyFiltersAndRender(true); // Apply initial sort/filter and render first batch

            } catch (error) {
                // Handle fetch errors (network error, server error, fallback error)
                err("Failed to fetch videos:", error);
                const displayMessage = error instanceof Error ? error.message : String(error);
                // Provide specific message if backend is likely needed
                 const backendNeededMsg = (VIDEO_FETCH_ENDPOINT === '/videos' && displayMessage.includes('404'))
                    ? " (Backend endpoint seems missing. Using local fallback if possible.)"
                    : "";
                displayGalleryMessage(`❌ Error loading videos: ${displayMessage}.${backendNeededMsg} Check console or backend.`, 'error');
                loadMoreBtn.style.display = 'none';
            } finally {
                isFetching = false; // Allow fetching again
            }
        }

         // --- Gallery Message Helpers ---
         function displayGalleryMessage(message, type = 'info') { // types: info, error, empty
             const gallery = safeGetElementById("gallery");
             if (!gallery) return;
             // Remove any existing messages first
             clearGalleryMessages();
             // Create and append new message
             const msgElement = document.createElement('p');
             msgElement.className = `gallery-message ${type}`;
             msgElement.textContent = message;
             gallery.appendChild(msgElement);
         }

         function clearGalleryMessages() {
            const gallery = safeGetElementById("gallery");
            if (!gallery) return;
            const messages = gallery.querySelectorAll('.gallery-message');
            messages.forEach(msg => msg.remove());
            // Also remove the initial loading message if it's still there
            const initialLoadingMsg = safeGetElementById('gallery-loading-msg');
            if(initialLoadingMsg) initialLoadingMsg.remove();
         }

        function applyFiltersAndRender(resetRendering = false) {
            log(`Applying filters. Filter: ${currentFilter}, Search: "${currentSearchQuery}", Reset: ${resetRendering}`);
            const gallery = safeGetElementById("gallery");
            if (!gallery) return;

            // Clear existing messages before filtering
            clearGalleryMessages();

            // Filtering by Search Query
            let filtered = allVideos;
            if (currentSearchQuery) {
                const query = currentSearchQuery.toLowerCase();
                filtered = allVideos.filter(video => {
                    if (!video || !video.public_id) return false; // Skip invalid entries
                    // Retrieve potential original filename from local storage if needed (fallback scenario)
                    const originalFilename = video.original_filename || localStorage.getItem(`filename_${video.public_id}`);
                    // Check locally stored title first, then formatted title, then uploader name
                    const title = (renamedTitles[video.public_id] || formatTitle(video.public_id, originalFilename)).toLowerCase();
                    const uploader = (uploaderNames[video.public_id] || 'Anonymous').toLowerCase();
                    return title.includes(query) || uploader.includes(query);
                });
                log(`Filtered by search "${query}", ${filtered.length} results.`);
            } else {
                 filtered = [...allVideos]; // Work on a copy if no search query
            }

            // Sorting
             log(`Sorting ${filtered.length} videos by ${currentFilter}`);
             try {
                switch (currentFilter) {
                    case 'popular':
                        // --- BACKEND REQUIRED for real Popularity Sort ---
                        // Sort by download_count descending if the backend provides it.
                        if (filtered.length > 0 && typeof filtered[0].download_count === 'number') {
                             filtered.sort((a, b) => (b.download_count || 0) - (a.download_count || 0));
                             log("Sorted by 'popular' (using download_count from backend).");
                        } else {
                             // Placeholder: Random sort if no download_count available
                             filtered.sort(() => Math.random() - 0.5);
                             log("Sorted by 'popular' (using RANDOM - backend download_count needed for real sort).");
                        }
                        break;
                    // 'relevant' case removed - requires backend search logic.
                    case 'recent': default:
                         // Ensure created_at exists and is valid before sorting
                         filtered.sort((a, b) => {
                             const dateA = a?.created_at ? new Date(a.created_at).getTime() : 0;
                             const dateB = b?.created_at ? new Date(b.created_at).getTime() : 0;
                             // Handle invalid dates gracefully - push them to the end
                             if (isNaN(dateA) && isNaN(dateB)) return 0;
                             if (isNaN(dateA)) return 1; // Put invalid A after valid B
                             if (isNaN(dateB)) return -1; // Put invalid B after valid A
                             return dateB - dateA; // Descending (newest first)
                         });
                         log("Sorted by 'recent'.");
                         break;
                }
            } catch (e) {
                err("Error during sorting:", e);
                // Continue with potentially unsorted or partially sorted list
            }

            displayedVideos = filtered; // Update the list that renderVideoBatch will use

            // Rendering
            if (resetRendering) {
                currentVideoIndex = 0; // Reset pagination index
                gallery.innerHTML = ''; // Clear previous gallery content completely
                // Display temporary message only if there are results to load
                if (displayedVideos.length > 0) {
                    displayGalleryMessage('🔄 Applying Filters & Loading...', 'info');
                    // Delay rendering slightly to ensure UI updates and message visibility
                    setTimeout(() => renderVideoBatch(true), 100);
                } else {
                    renderVideoBatch(true); // Render "no results" message immediately
                }
            } else {
                 renderVideoBatch(false); // Continue rendering next batch without clearing
            }
        }


        function renderVideoBatch(isInitialRender = false) {
            const gallery = safeGetElementById("gallery");
            const loadMoreBtn = safeGetElementById('loadMoreBtn');
            if (!gallery || !loadMoreBtn) return;

            // Clear temporary loading/filtering message if it exists
             const loadingMsg = gallery.querySelector('.gallery-message.info');
             if (loadingMsg && loadingMsg.textContent.includes('Loading')) {
                loadingMsg.remove();
             }

            const fragment = document.createDocumentFragment();
            const startIndex = currentVideoIndex;
            const endIndex = Math.min(startIndex + VIDEOS_PER_LOAD, displayedVideos.length);

            log(`Rendering batch from index ${startIndex} to ${endIndex - 1} (Total filtered/sorted: ${displayedVideos.length})`);

             if (isInitialRender && displayedVideos.length === 0) { // Handle No Results specifically on initial/reset render
                 const message = currentSearchQuery
                               ? `📪 No results found for "${currentSearchQuery}". Try a different search?`
                               : (allVideos.length === 0 ? '📪 No videos found yet! Be the first to upload.' : '📪 No videos match the current filter.');
                 displayGalleryMessage(message, 'empty');
                 loadMoreBtn.style.display = 'none';
                 return;
             }

             // Don't show loading state on button if nothing new to load in this call
            if (startIndex >= endIndex && !isInitialRender) {
                 log("No more videos to render in this batch call.");
            } else if (startIndex < endIndex) {
                 // Disable button while loading this batch
                 loadMoreBtn.disabled = true;
                 loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>Loading...';
            }

            for (let i = startIndex; i < endIndex; i++) {
                const file = displayedVideos[i];
                // Added check for secure_url which is crucial for rendering
                if (!file || !file.public_id || !file.secure_url) {
                     err(`Skipping invalid video data at index ${i} (missing public_id or secure_url):`, file);
                     continue; // Skip this item
                }
                const publicId = file.public_id;
                // Ensure ID is safe for CSS selectors and JS lookups
                const safeId = publicId.replace(/[^a-zA-Z0-9_-]/g, '_');
                // Retrieve potential original filename (needed for formatTitle)
                const originalFilename = file.original_filename || localStorage.getItem(`filename_${publicId}`); // Fallback for local-only scenario
                const title = renamedTitles[publicId] || formatTitle(publicId, originalFilename);
                const uploader = uploaderNames[publicId] || 'Anonymous';
                const videoUrl = file.secure_url; // Use the secure URL directly
                const downloadCount = typeof file.download_count === 'number' ? file.download_count : null; // Get download count if available

                 // Generate thumbnail URL using Cloudinary transformations
                // Fetches the frame at 1 second (so_1)
                const thumbnailUrl = `https://res.cloudinary.com/${CLOUD_NAME}/video/upload/w_300,h_169,c_fill,q_auto,f_auto,so_1/${publicId}.jpg`;

                const card = document.createElement('div');
                card.style.animationDelay = `${(i - startIndex) * 0.05}s`; // Stagger animation
                card.className = 'card';
                card.dataset.publicId = publicId; // Store ID for actions
                // Store original filename if available (useful for formatTitle if title not renamed)
                if (file.original_filename) card.dataset.originalFilename = file.original_filename;

                // Sanitize title for download attribute (replace potentially problematic chars)
                const safeDownloadFilename = `${title.replace(/[^a-z0-9_\-.]/gi, '_')}.mp4`;

                card.innerHTML = `
                    <div class="video-container">
                        <video muted playsinline loop preload="metadata" poster="${thumbnailUrl}" title="Click to play/pause: ${title}" data-public-id="${publicId}">
                            <source src="${videoUrl}" type="video/mp4">
                             <!-- Offer WebM as alternative for browsers that support it -->
                             <source src="${videoUrl.replace(/\.mp4$/, '.webm')}" type="video/webm">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                    <div class="card-content">
                        <div class="card-title" title="${title}">${title}</div>
                         <div class="meta-info"> <!-- Flex container for uploader and download count -->
                             ${downloadCount !== null ? `<span class="download-count" title="${downloadCount.toLocaleString()} downloads"><i class="fas fa-download" aria-hidden="true"></i> ${downloadCount.toLocaleString()}</span>` : '<div></div>' /* Empty div for spacing if no count */}
                             <div class="uploader-name" title="Uploaded by ${uploader}">by ${uploader}</div>
                         </div>
                    </div>
                    <div class="card-footer">
                        <a href="${videoUrl}" download="${safeDownloadFilename}" class="download-btn" title="Download ${title}">
                             <i class="fas fa-download" aria-hidden="true"></i><span class="ml-1">Download</span>
                        </a>
                        <button type="button" class="menu-btn" title="Video Options" aria-haspopup="true" aria-expanded="false" aria-controls="actionPopup_${safeId}">
                            <i class="fas fa-ellipsis-h" aria-hidden="true"></i>
                            <span class="sr-only">Options for ${title}</span>
                        </button>
                    </div>
                    <div class="action-popup" id="actionPopup_${safeId}" role="menu">
                        <button type="button" role="menuitem"><i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Rename</button>
                        <button type="button" role="menuitem" class="delete-action"><i class="fas fa-trash-alt fa-fw" aria-hidden="true"></i>Delete</button>
                    </div>
                `;
                fragment.appendChild(card);
            }

            gallery.appendChild(fragment);
            currentVideoIndex = endIndex; // Update the index for the next load

            // Update Load More button state AFTER rendering
            updateLoadMoreButtonState();
        }

        function formatTitle(publicId, originalFilename = null) {
            // Prioritize original filename if available and seems reasonable
             let nameSource = originalFilename || publicId || '';
             if (!nameSource) return "Untitled Video";

            try {
                // Get the part after the last slash (if any)
                let name = nameSource.includes('/') ? nameSource.substring(nameSource.lastIndexOf('/') + 1) : nameSource;
                // Remove common video extensions more robustly
                name = name.replace(/\.(mp4|webm|mov|avi|mkv|wmv|flv)$/i, "");
                // Replace underscores, hyphens, and periods (if not part of extension) with spaces
                name = name.replace(/[_\-\.]+/g, ' ');
                // Attempt to split camelCase or PascalCase
                name = name.replace(/([a-z])([A-Z])/g, '$1 $2');
                // Capitalize first letter of each word
                name = name.split(' ')
                           .map(word => word && word.length > 0 ? word.charAt(0).toUpperCase() + word.slice(1).toLowerCase() : '')
                           .join(' ').trim();
                // Remove potential leftover multiple spaces
                name = name.replace(/\s{2,}/g, ' ');
                // Handle cases where the name might just be random characters or empty after cleaning
                 const cleanedName = name.replace(/[^a-zA-Z0-9\s]/g, ''); // Remove non-alphanumeric/space chars for length check
                return cleanedName && cleanedName.length > 2 ? name : `Video Clip (${publicId.slice(-6)})`; // Use last 6 chars of ID if title is too short/generic
            } catch (e) {
                err("Error formatting title from:", nameSource, e);
                // Provide a simple fallback using the last part of the public_id
                const idParts = publicId.split('/');
                return idParts[idParts.length - 1] || "Untitled Video";
            }
        }


        // --- Video Card Actions ---
        function togglePlay(videoElement) {
            if (!videoElement) { err("togglePlay: videoElement is null"); return; }
            const container = videoElement.closest('.video-container');
            const publicId = videoElement.dataset.publicId; // Get ID from video element itself
            if (!publicId) { err("togglePlay: Cannot find publicId on video element."); return; }

            try {
                if (videoElement.paused) {
                    // Pause all other playing videos first
                    $$('.gallery video.playing').forEach(otherVideo => {
                         if (otherVideo !== videoElement) {
                             otherVideo.pause();
                             otherVideo.classList.remove('playing');
                             otherVideo.closest('.video-container')?.classList.remove('playing');
                         }
                     });
                    // Play this video
                    const playPromise = videoElement.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            log(`Playing video: ${publicId}`);
                            videoElement.classList.add('playing');
                            container?.classList.add('playing'); // Add class to container too (for hiding play icon)
                        }).catch(e => {
                             // Ignore common AbortError if user clicks quickly elsewhere
                             if (e.name !== 'AbortError') {
                                err(`Play error for ${publicId}:`, e);
                                // displayGalleryMessage(`Could not play video: ${e.message}`, 'error'); // Avoid message spam
                             } else {
                                 log(`Play interrupted for ${publicId}`);
                                 // Ensure state is reset if play was aborted
                                 videoElement.classList.remove('playing');
                                 container?.classList.remove('playing');
                             }
                        });
                    } else {
                        // Fallback for browsers not returning a promise (less common now)
                        log(`Playing video (no promise): ${publicId}`);
                        videoElement.classList.add('playing');
                        container?.classList.add('playing');
                    }
                } else {
                    videoElement.pause();
                    log(`Paused video: ${publicId}`);
                    videoElement.classList.remove('playing');
                    container?.classList.remove('playing');
                }
            } catch (e) {
                err("Error in togglePlay:", e);
                 // displayGalleryMessage(`Playback error: ${e.message}`, 'error');
            }
        }

        function toggleActionMenu(publicId, buttonElement) {
             log(`Toggling action menu for ${publicId}`);
             const safeId = publicId.replace(/[^a-zA-Z0-9_-]/g, '_');
             const popup = safeGetElementById(`actionPopup_${safeId}`);
             const menuButton = buttonElement || $(`button[aria-controls="actionPopup_${safeId}"]`);

             if (!popup || !menuButton) { err(`Action popup or button not found for ${safeId}.`); return; }

             const isOpening = popup.style.display !== 'block';

             // Close all other popups first *before* opening the new one
             $$('.action-popup').forEach(p => {
                 if (p !== popup && p.style.display === 'block') {
                     p.style.display = 'none';
                     const otherButton = $(`button[aria-controls="${p.id}"]`);
                     if (otherButton) otherButton.setAttribute('aria-expanded', 'false');
                     log(`Closed other popup: ${p.id}`);
                 }
             });

             // Toggle the target popup
             popup.style.display = isOpening ? 'block' : 'none';
             menuButton.setAttribute('aria-expanded', isOpening ? 'true' : 'false');

             if (isOpening) {
                 log(`Action popup ${popup.id} opened`);
                 // Optional: focus first item in the popup
                 popup.querySelector('button')?.focus();
            } else {
                 log(`Action popup ${popup.id} closed`);
                 // Optional: return focus to the menu button
                 menuButton.focus();
             }
        }

        // --- Password Protected Actions (Rename/Delete) ---
        function getPasswordAndExecute(publicId, actionCallback, actionName = "perform action") {
             log(`Getting password for ${actionName} on ${publicId}`);
             const storedPass = localStorage.getItem(`pass_${publicId}`);

             if (!storedPass) {
                 err(`No password found locally for ${publicId}`);
                 showPromptModal({
                     title: "<i class='fas fa-exclamation-triangle text-yellow-400 mr-2'></i> Password Missing",
                     isConfirmation: true,
                     contentHTML: `<p>The deletion/rename password for this video is not stored in this browser's local storage.</p><p>You might have uploaded it from a different browser, cleared your storage, or the password failed to save during upload.</p><p class="mt-2 text-sm text-gray-400">Unfortunately, the action cannot proceed without the correct password.</p>`,
                     confirmText: "OK",
                     confirmClass: 'modal-button-cancel', // Use cancel style for info button
                     callback: () => hidePromptModal() // Just close the info modal
                 });
                 return;
             }

             // Proceed to ask for password
             showPromptModal({
                 title: "<i class='fas fa-lock text-yellow-400 mr-2'></i> Password Required",
                 inputLabel: `Enter password to ${actionName}:`,
                 inputType: 'password',
                 placeholder: 'Enter your saved password',
                 confirmText: 'Verify & Proceed',
                 callback: (enteredPassword) => {
                     log("Password prompt callback executed."); // DEBUG
                     if (!enteredPassword) { // Handle empty input
                         showPromptError('Password cannot be empty.');
                         // Keep modal open
                         return;
                     }
                     if (enteredPassword === storedPass) {
                         log(`Password verified for ${actionName} on ${publicId}. Hiding prompt and executing action.`); // DEBUG
                         hidePromptModal(); // Hide prompt *before* executing action
                         // Use a small timeout to ensure the modal is hidden before the next action (which might show another modal)
                         setTimeout(() => {
                            log("Executing action callback after brief delay."); // DEBUG
                            actionCallback(); // Execute the intended action (rename or delete)
                         }, 50); // Short delay
                     } else {
                         log("Incorrect password entered.");
                         showPromptError('Incorrect password. Please try again.');
                         // Keep the modal open for another try
                         const inputField = safeGetElementById('promptInput');
                         if(inputField) inputField.focus(); // Refocus field
                     }
                 }
             });
        }

        function triggerRename(publicId) {
            log(`Triggering rename for ${publicId}`);
            getPasswordAndExecute(publicId, () => proceedWithRename(publicId), "rename video");
        }

        function proceedWithRename(publicId) {
             log(`Showing rename prompt for ${publicId}`);
             const card = $(`div.card[data-public-id="${publicId}"]`);
             // Try to get original filename from data attribute or local storage
             const originalFilename = card?.dataset.originalFilename || localStorage.getItem(`filename_${publicId}`);
             const currentTitle = renamedTitles[publicId] || formatTitle(publicId, originalFilename); // Use helper

             showPromptModal({
                 title: "<i class='fas fa-pencil-alt mr-2'></i> Rename Video",
                 inputLabel: `Enter new title for this overlay:`,
                 inputType: 'text',
                 initialValue: currentTitle,
                 placeholder: 'Enter a descriptive title',
                 confirmText: 'Save New Title',
                 callback: (newTitleInput) => {
                     const newTitle = newTitleInput?.trim();
                     if (newTitle && newTitle !== currentTitle) {
                         log(`Renaming ${publicId} locally from "${currentTitle}" to "${newTitle}"`);
                         renamedTitles[publicId] = newTitle;
                         try {
                             localStorage.setItem('renamedTitles', JSON.stringify(renamedTitles));
                             log("Title saved locally.");
                         } catch (e) {
                             err("Error saving renamed title to localStorage:", e);
                             showPromptError("Failed to save title locally.");
                             // Allow UI update anyway but log error.
                         }

                         // Update DOM immediately
                         if (card) {
                             const titleEl = card.querySelector('.card-title');
                             const downloadLink = card.querySelector('.download-btn');
                             const videoEl = card.querySelector('video');
                             if (titleEl) { titleEl.textContent = newTitle; titleEl.title = newTitle; }
                             if (downloadLink) {
                                const safeFilename = `${newTitle.replace(/[^a-z0-9_\-.]/gi, '_')}.mp4`;
                                downloadLink.download = safeFilename;
                                downloadLink.title = `Download ${newTitle}`;
                             }
                              if (videoEl) videoEl.title = `Click to play/pause: ${newTitle}`;
                         }
                         hidePromptModal(); // Hide on success
                         log("Rename successful (locally).");
                         // Optional: Call a backend endpoint to save the title server-side if needed
                         // updateBackendTitle(publicId, newTitle);
                     } else if (!newTitle) {
                          showPromptError("Title cannot be empty.");
                          // Keep modal open
                          const inputField = safeGetElementById('promptInput');
                          if(inputField) inputField.focus(); // Refocus field
                     } else {
                          log("Title unchanged, closing rename prompt.");
                          hidePromptModal(); // Title unchanged, just close
                     }
                 }
             });
        }

        function triggerDelete(publicId) {
            log(`Triggering delete for ${publicId}`);
             getPasswordAndExecute(publicId, () => proceedWithDelete(publicId), "delete video");
        }

        async function proceedWithDelete(publicId) { // Make async for await fetch
             log(`>>> Inside proceedWithDelete for ${publicId}. Showing confirmation prompt...`); // DEBUG
             const card = $(`div.card[data-public-id="${publicId}"]`);
             // Try to get original filename from data attribute or local storage
             const originalFilename = card?.dataset.originalFilename || localStorage.getItem(`filename_${publicId}`);
             const title = renamedTitles[publicId] || formatTitle(publicId, originalFilename);

             showPromptModal({
                 isConfirmation: true, // This tells the modal not to show an input field
                 title: "<i class='fas fa-trash-alt text-red-500 mr-2'></i> Confirm Deletion",
                 contentHTML: `<p>Are you absolutely sure you want to permanently delete the overlay:</p><p class="font-bold my-2 break-words">"${title}"?</p><p class="text-red-400 font-semibold">This action requires server interaction (if backend is configured) and cannot be undone.</p>`,
                 confirmText: "Yes, Delete Forever",
                 cancelText: "Cancel",
                 confirmClass: 'modal-button-delete', // Use red button style
                 callback: async (confirmed) => { // Make callback async to await fetch
                     log(`>>> Delete confirmation callback executed. Confirmed: ${confirmed}`); // DEBUG
                     if (confirmed) {
                         log(`Deletion confirmed for ${publicId}. Initiating server deletion...`);
                         hidePromptModal(); // Hide confirmation modal
                         const cardToDelete = $(`div.card[data-public-id="${publicId}"]`);

                         // Add visual indicator while deleting
                         if (cardToDelete) cardToDelete.style.opacity = '0.5';

                         // --- BACKEND INTERACTION REQUIRED for Persistent Deletion ---
                         let serverDeletionSuccess = false;
                         let backendError = null;
                         try {
                             if (!VIDEO_DELETE_ENDPOINT_BASE || VIDEO_DELETE_ENDPOINT_BASE === '/delete') { // Check if endpoint is valid
                                 log("Backend delete endpoint not configured or invalid. Proceeding with local removal only.");
                                 // Skip fetch, treat as 'success' for local removal
                             } else {
                                 const deleteUrl = `${VIDEO_DELETE_ENDPOINT_BASE}/${encodeURIComponent(publicId)}`;
                                 log(`Sending DELETE request to: ${deleteUrl}`);

                                 const response = await fetch(deleteUrl, { method: 'DELETE' });

                                 if (!response.ok) {
                                     // Handle common case where endpoint doesn't exist gracefully
                                     if (response.status === 404) {
                                          log("Backend delete endpoint not found (404). Proceeding with local removal only.");
                                          // Treat as 'success' for local removal purposes, but not true deletion
                                     } else {
                                          let errorMsg = `Server Error: ${response.status} ${response.statusText}`;
                                          try {
                                              const errData = await response.json();
                                              errorMsg = errData.message || `Failed with status ${response.status}`;
                                              err("Server deletion error details:", errData);
                                          } catch (e) { /* Ignore if parsing fails */ }
                                          throw new Error(errorMsg); // Throw for other server errors
                                     }
                                 } else {
                                     // Check for success response (e.g., 200 OK with JSON, or 204 No Content)
                                     log(`Server response status: ${response.status}`);
                                     if (response.status === 204) { // No Content is success
                                          log(`Successfully deleted ${publicId} from server (204 No Content).`);
                                     } else { // Assume 200 OK might have content
                                          try {
                                              const responseData = await response.json();
                                              log(`Successfully deleted ${publicId} from server. Response:`, responseData);
                                              if (responseData.status === "error" || responseData.success === false) {
                                                  throw new Error(responseData.message || "Deletion reported failed by server.");
                                              }
                                          } catch(parseError) {
                                              err("Could not parse successful delete response, assuming OK based on status 200.", parseError);
                                          }
                                     }
                                     serverDeletionSuccess = true; // Mark as successful server deletion
                                 }
                             }

                         } catch (error) {
                             // This catch block handles fetch errors or thrown server errors
                             err(`Deletion failed for ${publicId}:`, error);
                             backendError = error; // Store the error to show user
                         }

                         // --- Perform Local Cleanup ---
                         // Proceed with local removal even if backend failed, BUT show error message if it did.
                         log(`Proceeding with local removal of ${publicId}. Server success: ${serverDeletionSuccess}`);

                         // 1. Animate and remove card from DOM
                         if (cardToDelete) {
                              cardToDelete.classList.add('deleting'); // Add class for transition
                              cardToDelete.addEventListener('transitionend', () => {
                                 cardToDelete.remove();
                                 log(`Card removed from DOM for ${publicId}`);
                                 // Check if gallery is empty after removing card
                                 const gallery = safeGetElementById('gallery');
                                 if (gallery && gallery.children.length === 0) {
                                     log("Gallery empty after deletion, re-rendering to show message.");
                                     applyFiltersAndRender(true); // Re-render to show 'no videos' message
                                 } else {
                                     updateLoadMoreButtonState(); // Check button state
                                 }
                              }, { once: true });
                         } else {
                              log("Card already removed or not found for DOM removal.");
                         }

                         // 2. Clean up local storage
                         localStorage.removeItem(`pass_${publicId}`);
                         localStorage.removeItem(`filename_${publicId}`); // Also remove filename
                         delete renamedTitles[publicId];
                         delete uploaderNames[publicId];
                         try {
                              localStorage.setItem('renamedTitles', JSON.stringify(renamedTitles));
                              localStorage.setItem('uploaderNames', JSON.stringify(uploaderNames));
                              log(`Cleaned up local storage for ${publicId}.`);
                         } catch (e) {
                              err("Error cleaning up localStorage after delete:", e);
                         }

                         // 3. Remove from main 'allVideos' and 'displayedVideos' arrays in memory
                         allVideos = allVideos.filter(v => v?.public_id !== publicId);
                         displayedVideos = displayedVideos.filter(v => v?.public_id !== publicId);

                         // 4. Update Load More button state if necessary (will be handled by transitionend removal check)
                         // updateLoadMoreButtonState();

                         // 5. Show Error Message if backend deletion failed
                         if (backendError) {
                              // Use a timeout to ensure the previous modal is fully gone
                              setTimeout(() => {
                                showPromptModal({
                                    title: "<i class='fas fa-exclamation-circle text-red-500 mr-2'></i> Deletion Error",
                                    isConfirmation: true,
                                    contentHTML: `<p>Failed to delete the video from the server:</p><p class="my-2 text-red-400">${backendError.message}</p><p>The video has been removed from your local view, but might still exist on the server.</p>`,
                                    confirmText: "OK",
                                    confirmClass: 'modal-button-cancel',
                                    callback: () => hidePromptModal()
                                });
                             }, 100); // Short delay for modal transition
                         } else {
                             log(`Local removal complete for ${publicId}.`);
                         }

                     } else {
                        log("Deletion cancelled by user.");
                        hidePromptModal(); // Just close if cancelled
                    }
                 }
             });
        }

        // Helper to update Load More button visibility and state
        function updateLoadMoreButtonState() {
             const loadMoreBtn = safeGetElementById('loadMoreBtn');
             const gallery = safeGetElementById('gallery');
             if (!loadMoreBtn || !gallery) return;

              // Remove any existing end-of-list message first
             const existingEndMsg = gallery.querySelector('.gallery-message.end-of-list');
             if (existingEndMsg) existingEndMsg.remove();

             if (currentVideoIndex >= displayedVideos.length) {
                 loadMoreBtn.style.display = 'none';
                 // Only add 'end of list' message if there are videos displayed and the gallery isn't showing other messages
                 if (displayedVideos.length > 0 && gallery.children.length > 0 && !gallery.querySelector('.gallery-message:not(.end-of-list)')) {
                      const endMsg = document.createElement('p');
                      endMsg.className = 'gallery-message info end-of-list'; // Added end-of-list class
                      endMsg.innerHTML = "✨ You've reached the end! ✨"; // Use innerHTML for emoji
                      // Append after a short delay to avoid flash if content is still rendering
                      setTimeout(() => {
                           // Check again if gallery still exists and doesn't have the message
                           const currentGallery = safeGetElementById('gallery');
                           if(currentGallery && !currentGallery.querySelector('.gallery-message.end-of-list')) {
                                currentGallery.appendChild(endMsg);
                           }
                      }, 150); // Slightly longer delay
                 }
             } else {
                  loadMoreBtn.style.display = 'block';
                  loadMoreBtn.disabled = false; // Ensure button is enabled
                  loadMoreBtn.innerHTML = 'Load More Videos'; // Reset button text
             }
        }</script>
